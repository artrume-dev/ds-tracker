
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model TokenHistory
 * 
 */
export type TokenHistory = $Result.DefaultSelection<Prisma.$TokenHistoryPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model TokenUsage
 * 
 */
export type TokenUsage = $Result.DefaultSelection<Prisma.$TokenUsagePayload>
/**
 * Model Pattern
 * 
 */
export type Pattern = $Result.DefaultSelection<Prisma.$PatternPayload>
/**
 * Model PatternToken
 * 
 */
export type PatternToken = $Result.DefaultSelection<Prisma.$PatternTokenPayload>
/**
 * Model PatternUsage
 * 
 */
export type PatternUsage = $Result.DefaultSelection<Prisma.$PatternUsagePayload>
/**
 * Model TokenDependency
 * 
 */
export type TokenDependency = $Result.DefaultSelection<Prisma.$TokenDependencyPayload>
/**
 * Model ChangeRequest
 * 
 */
export type ChangeRequest = $Result.DefaultSelection<Prisma.$ChangeRequestPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ScanResult
 * 
 */
export type ScanResult = $Result.DefaultSelection<Prisma.$ScanResultPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  DESIGNER: 'DESIGNER',
  DEVELOPER: 'DEVELOPER',
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TokenCategory: {
  COLOR: 'COLOR',
  TYPOGRAPHY: 'TYPOGRAPHY',
  SPACING: 'SPACING',
  SHADOW: 'SHADOW',
  BORDER: 'BORDER',
  ANIMATION: 'ANIMATION',
  BREAKPOINT: 'BREAKPOINT'
};

export type TokenCategory = (typeof TokenCategory)[keyof typeof TokenCategory]


export const Criticality: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Criticality = (typeof Criticality)[keyof typeof Criticality]


export const DeprecationStatus: {
  STABLE: 'STABLE',
  DEPRECATED: 'DEPRECATED',
  SUNSET: 'SUNSET'
};

export type DeprecationStatus = (typeof DeprecationStatus)[keyof typeof DeprecationStatus]


export const AppType: {
  WEBSITE: 'WEBSITE',
  MOBILE_APP: 'MOBILE_APP',
  DESKTOP_APP: 'DESKTOP_APP',
  EMAIL: 'EMAIL',
  SOCIAL: 'SOCIAL'
};

export type AppType = (typeof AppType)[keyof typeof AppType]


export const AppStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ERROR: 'ERROR'
};

export type AppStatus = (typeof AppStatus)[keyof typeof AppStatus]


export const Implementation: {
  CSS_VARIABLES: 'CSS_VARIABLES',
  SCSS_IMPORT: 'SCSS_IMPORT',
  JS_OBJECT: 'JS_OBJECT',
  DESIGN_TOKENS: 'DESIGN_TOKENS'
};

export type Implementation = (typeof Implementation)[keyof typeof Implementation]


export const Complexity: {
  SIMPLE: 'SIMPLE',
  MEDIUM: 'MEDIUM',
  COMPLEX: 'COMPLEX'
};

export type Complexity = (typeof Complexity)[keyof typeof Complexity]


export const DependencyType: {
  USES: 'USES',
  EXTENDS: 'EXTENDS',
  REFERENCES: 'REFERENCES'
};

export type DependencyType = (typeof DependencyType)[keyof typeof DependencyType]


export const ChangeType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  DEPRECATE: 'DEPRECATE'
};

export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]


export const RequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  IN_REVIEW: 'IN_REVIEW'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const NotificationType: {
  TOKEN_CREATED: 'TOKEN_CREATED',
  TOKEN_UPDATED: 'TOKEN_UPDATED',
  TOKEN_DEPRECATED: 'TOKEN_DEPRECATED',
  CHANGE_REQUEST: 'CHANGE_REQUEST',
  APPROVAL_REQUIRED: 'APPROVAL_REQUIRED',
  SCAN_COMPLETED: 'SCAN_COMPLETED',
  SYSTEM_ALERT: 'SYSTEM_ALERT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TokenCategory = $Enums.TokenCategory

export const TokenCategory: typeof $Enums.TokenCategory

export type Criticality = $Enums.Criticality

export const Criticality: typeof $Enums.Criticality

export type DeprecationStatus = $Enums.DeprecationStatus

export const DeprecationStatus: typeof $Enums.DeprecationStatus

export type AppType = $Enums.AppType

export const AppType: typeof $Enums.AppType

export type AppStatus = $Enums.AppStatus

export const AppStatus: typeof $Enums.AppStatus

export type Implementation = $Enums.Implementation

export const Implementation: typeof $Enums.Implementation

export type Complexity = $Enums.Complexity

export const Complexity: typeof $Enums.Complexity

export type DependencyType = $Enums.DependencyType

export const DependencyType: typeof $Enums.DependencyType

export type ChangeType = $Enums.ChangeType

export const ChangeType: typeof $Enums.ChangeType

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs>;

  /**
   * `prisma.tokenHistory`: Exposes CRUD operations for the **TokenHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenHistories
    * const tokenHistories = await prisma.tokenHistory.findMany()
    * ```
    */
  get tokenHistory(): Prisma.TokenHistoryDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs>;

  /**
   * `prisma.tokenUsage`: Exposes CRUD operations for the **TokenUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenUsages
    * const tokenUsages = await prisma.tokenUsage.findMany()
    * ```
    */
  get tokenUsage(): Prisma.TokenUsageDelegate<ExtArgs>;

  /**
   * `prisma.pattern`: Exposes CRUD operations for the **Pattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patterns
    * const patterns = await prisma.pattern.findMany()
    * ```
    */
  get pattern(): Prisma.PatternDelegate<ExtArgs>;

  /**
   * `prisma.patternToken`: Exposes CRUD operations for the **PatternToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatternTokens
    * const patternTokens = await prisma.patternToken.findMany()
    * ```
    */
  get patternToken(): Prisma.PatternTokenDelegate<ExtArgs>;

  /**
   * `prisma.patternUsage`: Exposes CRUD operations for the **PatternUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatternUsages
    * const patternUsages = await prisma.patternUsage.findMany()
    * ```
    */
  get patternUsage(): Prisma.PatternUsageDelegate<ExtArgs>;

  /**
   * `prisma.tokenDependency`: Exposes CRUD operations for the **TokenDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenDependencies
    * const tokenDependencies = await prisma.tokenDependency.findMany()
    * ```
    */
  get tokenDependency(): Prisma.TokenDependencyDelegate<ExtArgs>;

  /**
   * `prisma.changeRequest`: Exposes CRUD operations for the **ChangeRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeRequests
    * const changeRequests = await prisma.changeRequest.findMany()
    * ```
    */
  get changeRequest(): Prisma.ChangeRequestDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.scanResult`: Exposes CRUD operations for the **ScanResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScanResults
    * const scanResults = await prisma.scanResult.findMany()
    * ```
    */
  get scanResult(): Prisma.ScanResultDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Token: 'Token',
    TokenHistory: 'TokenHistory',
    Team: 'Team',
    Application: 'Application',
    TokenUsage: 'TokenUsage',
    Pattern: 'Pattern',
    PatternToken: 'PatternToken',
    PatternUsage: 'PatternUsage',
    TokenDependency: 'TokenDependency',
    ChangeRequest: 'ChangeRequest',
    Notification: 'Notification',
    ScanResult: 'ScanResult'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "token" | "tokenHistory" | "team" | "application" | "tokenUsage" | "pattern" | "patternToken" | "patternUsage" | "tokenDependency" | "changeRequest" | "notification" | "scanResult"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      TokenHistory: {
        payload: Prisma.$TokenHistoryPayload<ExtArgs>
        fields: Prisma.TokenHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>
          }
          findFirst: {
            args: Prisma.TokenHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>
          }
          findMany: {
            args: Prisma.TokenHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>[]
          }
          create: {
            args: Prisma.TokenHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>
          }
          createMany: {
            args: Prisma.TokenHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>[]
          }
          delete: {
            args: Prisma.TokenHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>
          }
          update: {
            args: Prisma.TokenHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>
          }
          deleteMany: {
            args: Prisma.TokenHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHistoryPayload>
          }
          aggregate: {
            args: Prisma.TokenHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenHistory>
          }
          groupBy: {
            args: Prisma.TokenHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<TokenHistoryCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      TokenUsage: {
        payload: Prisma.$TokenUsagePayload<ExtArgs>
        fields: Prisma.TokenUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>
          }
          findFirst: {
            args: Prisma.TokenUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>
          }
          findMany: {
            args: Prisma.TokenUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>[]
          }
          create: {
            args: Prisma.TokenUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>
          }
          createMany: {
            args: Prisma.TokenUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>[]
          }
          delete: {
            args: Prisma.TokenUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>
          }
          update: {
            args: Prisma.TokenUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>
          }
          deleteMany: {
            args: Prisma.TokenUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenUsagePayload>
          }
          aggregate: {
            args: Prisma.TokenUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenUsage>
          }
          groupBy: {
            args: Prisma.TokenUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenUsageCountArgs<ExtArgs>
            result: $Utils.Optional<TokenUsageCountAggregateOutputType> | number
          }
        }
      }
      Pattern: {
        payload: Prisma.$PatternPayload<ExtArgs>
        fields: Prisma.PatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          findFirst: {
            args: Prisma.PatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          findMany: {
            args: Prisma.PatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>[]
          }
          create: {
            args: Prisma.PatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          createMany: {
            args: Prisma.PatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>[]
          }
          delete: {
            args: Prisma.PatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          update: {
            args: Prisma.PatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          deleteMany: {
            args: Prisma.PatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPayload>
          }
          aggregate: {
            args: Prisma.PatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePattern>
          }
          groupBy: {
            args: Prisma.PatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternCountArgs<ExtArgs>
            result: $Utils.Optional<PatternCountAggregateOutputType> | number
          }
        }
      }
      PatternToken: {
        payload: Prisma.$PatternTokenPayload<ExtArgs>
        fields: Prisma.PatternTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>
          }
          findFirst: {
            args: Prisma.PatternTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>
          }
          findMany: {
            args: Prisma.PatternTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>[]
          }
          create: {
            args: Prisma.PatternTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>
          }
          createMany: {
            args: Prisma.PatternTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>[]
          }
          delete: {
            args: Prisma.PatternTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>
          }
          update: {
            args: Prisma.PatternTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>
          }
          deleteMany: {
            args: Prisma.PatternTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatternTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTokenPayload>
          }
          aggregate: {
            args: Prisma.PatternTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatternToken>
          }
          groupBy: {
            args: Prisma.PatternTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PatternTokenCountAggregateOutputType> | number
          }
        }
      }
      PatternUsage: {
        payload: Prisma.$PatternUsagePayload<ExtArgs>
        fields: Prisma.PatternUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>
          }
          findFirst: {
            args: Prisma.PatternUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>
          }
          findMany: {
            args: Prisma.PatternUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>[]
          }
          create: {
            args: Prisma.PatternUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>
          }
          createMany: {
            args: Prisma.PatternUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>[]
          }
          delete: {
            args: Prisma.PatternUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>
          }
          update: {
            args: Prisma.PatternUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>
          }
          deleteMany: {
            args: Prisma.PatternUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatternUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternUsagePayload>
          }
          aggregate: {
            args: Prisma.PatternUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatternUsage>
          }
          groupBy: {
            args: Prisma.PatternUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternUsageCountArgs<ExtArgs>
            result: $Utils.Optional<PatternUsageCountAggregateOutputType> | number
          }
        }
      }
      TokenDependency: {
        payload: Prisma.$TokenDependencyPayload<ExtArgs>
        fields: Prisma.TokenDependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenDependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenDependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>
          }
          findFirst: {
            args: Prisma.TokenDependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenDependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>
          }
          findMany: {
            args: Prisma.TokenDependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>[]
          }
          create: {
            args: Prisma.TokenDependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>
          }
          createMany: {
            args: Prisma.TokenDependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenDependencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>[]
          }
          delete: {
            args: Prisma.TokenDependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>
          }
          update: {
            args: Prisma.TokenDependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>
          }
          deleteMany: {
            args: Prisma.TokenDependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenDependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenDependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenDependencyPayload>
          }
          aggregate: {
            args: Prisma.TokenDependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenDependency>
          }
          groupBy: {
            args: Prisma.TokenDependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenDependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenDependencyCountArgs<ExtArgs>
            result: $Utils.Optional<TokenDependencyCountAggregateOutputType> | number
          }
        }
      }
      ChangeRequest: {
        payload: Prisma.$ChangeRequestPayload<ExtArgs>
        fields: Prisma.ChangeRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          findFirst: {
            args: Prisma.ChangeRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          findMany: {
            args: Prisma.ChangeRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          create: {
            args: Prisma.ChangeRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          createMany: {
            args: Prisma.ChangeRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          delete: {
            args: Prisma.ChangeRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          update: {
            args: Prisma.ChangeRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          deleteMany: {
            args: Prisma.ChangeRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChangeRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          aggregate: {
            args: Prisma.ChangeRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeRequest>
          }
          groupBy: {
            args: Prisma.ChangeRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeRequestCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ScanResult: {
        payload: Prisma.$ScanResultPayload<ExtArgs>
        fields: Prisma.ScanResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScanResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScanResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          findFirst: {
            args: Prisma.ScanResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScanResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          findMany: {
            args: Prisma.ScanResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>[]
          }
          create: {
            args: Prisma.ScanResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          createMany: {
            args: Prisma.ScanResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScanResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>[]
          }
          delete: {
            args: Prisma.ScanResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          update: {
            args: Prisma.ScanResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          deleteMany: {
            args: Prisma.ScanResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScanResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScanResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScanResultPayload>
          }
          aggregate: {
            args: Prisma.ScanResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScanResult>
          }
          groupBy: {
            args: Prisma.ScanResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScanResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScanResultCountArgs<ExtArgs>
            result: $Utils.Optional<ScanResultCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tokensCreated: number
    changeRequests: number
    approvals: number
    tokenHistory: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokensCreated?: boolean | UserCountOutputTypeCountTokensCreatedArgs
    changeRequests?: boolean | UserCountOutputTypeCountChangeRequestsArgs
    approvals?: boolean | UserCountOutputTypeCountApprovalsArgs
    tokenHistory?: boolean | UserCountOutputTypeCountTokenHistoryArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokenHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type TokenCountOutputType
   */

  export type TokenCountOutputType = {
    history: number
    usages: number
    patterns: number
    dependencies: number
    dependents: number
    changeRequests: number
  }

  export type TokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | TokenCountOutputTypeCountHistoryArgs
    usages?: boolean | TokenCountOutputTypeCountUsagesArgs
    patterns?: boolean | TokenCountOutputTypeCountPatternsArgs
    dependencies?: boolean | TokenCountOutputTypeCountDependenciesArgs
    dependents?: boolean | TokenCountOutputTypeCountDependentsArgs
    changeRequests?: boolean | TokenCountOutputTypeCountChangeRequestsArgs
  }

  // Custom InputTypes
  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenCountOutputType
     */
    select?: TokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenHistoryWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenUsageWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternTokenWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenDependencyWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenDependencyWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    applications: number
    tokenUsages: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | TeamCountOutputTypeCountApplicationsArgs
    tokenUsages?: boolean | TeamCountOutputTypeCountTokenUsagesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTokenUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenUsageWhereInput
  }


  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    tokenUsages: number
    scanResults: number
  }

  export type ApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokenUsages?: boolean | ApplicationCountOutputTypeCountTokenUsagesArgs
    scanResults?: boolean | ApplicationCountOutputTypeCountScanResultsArgs
  }

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountTokenUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenUsageWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountScanResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScanResultWhereInput
  }


  /**
   * Count Type PatternCountOutputType
   */

  export type PatternCountOutputType = {
    tokens: number
    usages: number
  }

  export type PatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | PatternCountOutputTypeCountTokensArgs
    usages?: boolean | PatternCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * PatternCountOutputType without action
   */
  export type PatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternCountOutputType
     */
    select?: PatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatternCountOutputType without action
   */
  export type PatternCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternTokenWhereInput
  }

  /**
   * PatternCountOutputType without action
   */
  export type PatternCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternUsageWhereInput
  }


  /**
   * Count Type ChangeRequestCountOutputType
   */

  export type ChangeRequestCountOutputType = {
    notifications: number
  }

  export type ChangeRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | ChangeRequestCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ChangeRequestCountOutputType without action
   */
  export type ChangeRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequestCountOutputType
     */
    select?: ChangeRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChangeRequestCountOutputType without action
   */
  export type ChangeRequestCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    team: string | null
    role: $Enums.Role | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    team: string | null
    role: $Enums.Role | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    team: number
    role: number
    avatarUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    team?: true
    role?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    team?: true
    role?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    team?: true
    role?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    team: string
    role: $Enums.Role
    avatarUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    team?: boolean
    role?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokensCreated?: boolean | User$tokensCreatedArgs<ExtArgs>
    changeRequests?: boolean | User$changeRequestsArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    tokenHistory?: boolean | User$tokenHistoryArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    team?: boolean
    role?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    team?: boolean
    role?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokensCreated?: boolean | User$tokensCreatedArgs<ExtArgs>
    changeRequests?: boolean | User$changeRequestsArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    tokenHistory?: boolean | User$tokenHistoryArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tokensCreated: Prisma.$TokenPayload<ExtArgs>[]
      changeRequests: Prisma.$ChangeRequestPayload<ExtArgs>[]
      approvals: Prisma.$ChangeRequestPayload<ExtArgs>[]
      tokenHistory: Prisma.$TokenHistoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      team: string
      role: $Enums.Role
      avatarUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tokensCreated<T extends User$tokensCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany"> | Null>
    changeRequests<T extends User$changeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$changeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends User$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany"> | Null>
    tokenHistory<T extends User$tokenHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$tokenHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly team: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tokensCreated
   */
  export type User$tokensCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.changeRequests
   */
  export type User$changeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    cursor?: ChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * User.approvals
   */
  export type User$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    cursor?: ChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * User.tokenHistory
   */
  export type User$tokenHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    where?: TokenHistoryWhereInput
    orderBy?: TokenHistoryOrderByWithRelationInput | TokenHistoryOrderByWithRelationInput[]
    cursor?: TokenHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenHistoryScalarFieldEnum | TokenHistoryScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    tokenId: string | null
    name: string | null
    currentVersion: string | null
    category: $Enums.TokenCategory | null
    criticality: $Enums.Criticality | null
    reviewRequired: boolean | null
    deprecationStatus: $Enums.DeprecationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    tokenId: string | null
    name: string | null
    currentVersion: string | null
    category: $Enums.TokenCategory | null
    criticality: $Enums.Criticality | null
    reviewRequired: boolean | null
    deprecationStatus: $Enums.DeprecationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    tokenId: number
    name: number
    currentVersion: number
    value: number
    category: number
    criticality: number
    reviewRequired: number
    deprecationStatus: number
    createdAt: number
    updatedAt: number
    creatorId: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    id?: true
    tokenId?: true
    name?: true
    currentVersion?: true
    category?: true
    criticality?: true
    reviewRequired?: true
    deprecationStatus?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    tokenId?: true
    name?: true
    currentVersion?: true
    category?: true
    criticality?: true
    reviewRequired?: true
    deprecationStatus?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    tokenId?: true
    name?: true
    currentVersion?: true
    value?: true
    category?: true
    criticality?: true
    reviewRequired?: true
    deprecationStatus?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonValue
    category: $Enums.TokenCategory
    criticality: $Enums.Criticality
    reviewRequired: boolean
    deprecationStatus: $Enums.DeprecationStatus
    createdAt: Date
    updatedAt: Date
    creatorId: string
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    name?: boolean
    currentVersion?: boolean
    value?: boolean
    category?: boolean
    criticality?: boolean
    reviewRequired?: boolean
    deprecationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    history?: boolean | Token$historyArgs<ExtArgs>
    usages?: boolean | Token$usagesArgs<ExtArgs>
    patterns?: boolean | Token$patternsArgs<ExtArgs>
    dependencies?: boolean | Token$dependenciesArgs<ExtArgs>
    dependents?: boolean | Token$dependentsArgs<ExtArgs>
    changeRequests?: boolean | Token$changeRequestsArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    name?: boolean
    currentVersion?: boolean
    value?: boolean
    category?: boolean
    criticality?: boolean
    reviewRequired?: boolean
    deprecationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    tokenId?: boolean
    name?: boolean
    currentVersion?: boolean
    value?: boolean
    category?: boolean
    criticality?: boolean
    reviewRequired?: boolean
    deprecationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
  }

  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    history?: boolean | Token$historyArgs<ExtArgs>
    usages?: boolean | Token$usagesArgs<ExtArgs>
    patterns?: boolean | Token$patternsArgs<ExtArgs>
    dependencies?: boolean | Token$dependenciesArgs<ExtArgs>
    dependents?: boolean | Token$dependentsArgs<ExtArgs>
    changeRequests?: boolean | Token$changeRequestsArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      history: Prisma.$TokenHistoryPayload<ExtArgs>[]
      usages: Prisma.$TokenUsagePayload<ExtArgs>[]
      patterns: Prisma.$PatternTokenPayload<ExtArgs>[]
      dependencies: Prisma.$TokenDependencyPayload<ExtArgs>[]
      dependents: Prisma.$TokenDependencyPayload<ExtArgs>[]
      changeRequests: Prisma.$ChangeRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenId: string
      name: string
      currentVersion: string
      value: Prisma.JsonValue
      category: $Enums.TokenCategory
      criticality: $Enums.Criticality
      reviewRequired: boolean
      deprecationStatus: $Enums.DeprecationStatus
      createdAt: Date
      updatedAt: Date
      creatorId: string
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    history<T extends Token$historyArgs<ExtArgs> = {}>(args?: Subset<T, Token$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    usages<T extends Token$usagesArgs<ExtArgs> = {}>(args?: Subset<T, Token$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findMany"> | Null>
    patterns<T extends Token$patternsArgs<ExtArgs> = {}>(args?: Subset<T, Token$patternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findMany"> | Null>
    dependencies<T extends Token$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Token$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    dependents<T extends Token$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Token$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    changeRequests<T extends Token$changeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Token$changeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly tokenId: FieldRef<"Token", 'String'>
    readonly name: FieldRef<"Token", 'String'>
    readonly currentVersion: FieldRef<"Token", 'String'>
    readonly value: FieldRef<"Token", 'Json'>
    readonly category: FieldRef<"Token", 'TokenCategory'>
    readonly criticality: FieldRef<"Token", 'Criticality'>
    readonly reviewRequired: FieldRef<"Token", 'Boolean'>
    readonly deprecationStatus: FieldRef<"Token", 'DeprecationStatus'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly updatedAt: FieldRef<"Token", 'DateTime'>
    readonly creatorId: FieldRef<"Token", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
  }

  /**
   * Token.history
   */
  export type Token$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    where?: TokenHistoryWhereInput
    orderBy?: TokenHistoryOrderByWithRelationInput | TokenHistoryOrderByWithRelationInput[]
    cursor?: TokenHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenHistoryScalarFieldEnum | TokenHistoryScalarFieldEnum[]
  }

  /**
   * Token.usages
   */
  export type Token$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    where?: TokenUsageWhereInput
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    cursor?: TokenUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenUsageScalarFieldEnum | TokenUsageScalarFieldEnum[]
  }

  /**
   * Token.patterns
   */
  export type Token$patternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    where?: PatternTokenWhereInput
    orderBy?: PatternTokenOrderByWithRelationInput | PatternTokenOrderByWithRelationInput[]
    cursor?: PatternTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternTokenScalarFieldEnum | PatternTokenScalarFieldEnum[]
  }

  /**
   * Token.dependencies
   */
  export type Token$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    where?: TokenDependencyWhereInput
    orderBy?: TokenDependencyOrderByWithRelationInput | TokenDependencyOrderByWithRelationInput[]
    cursor?: TokenDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenDependencyScalarFieldEnum | TokenDependencyScalarFieldEnum[]
  }

  /**
   * Token.dependents
   */
  export type Token$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    where?: TokenDependencyWhereInput
    orderBy?: TokenDependencyOrderByWithRelationInput | TokenDependencyOrderByWithRelationInput[]
    cursor?: TokenDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenDependencyScalarFieldEnum | TokenDependencyScalarFieldEnum[]
  }

  /**
   * Token.changeRequests
   */
  export type Token$changeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    cursor?: ChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model TokenHistory
   */

  export type AggregateTokenHistory = {
    _count: TokenHistoryCountAggregateOutputType | null
    _min: TokenHistoryMinAggregateOutputType | null
    _max: TokenHistoryMaxAggregateOutputType | null
  }

  export type TokenHistoryMinAggregateOutputType = {
    id: string | null
    version: string | null
    changedAt: Date | null
    approvedAt: Date | null
    tokenId: string | null
    changedById: string | null
  }

  export type TokenHistoryMaxAggregateOutputType = {
    id: string | null
    version: string | null
    changedAt: Date | null
    approvedAt: Date | null
    tokenId: string | null
    changedById: string | null
  }

  export type TokenHistoryCountAggregateOutputType = {
    id: number
    version: number
    changes: number
    changedAt: number
    approvedAt: number
    rollbackInfo: number
    tokenId: number
    changedById: number
    _all: number
  }


  export type TokenHistoryMinAggregateInputType = {
    id?: true
    version?: true
    changedAt?: true
    approvedAt?: true
    tokenId?: true
    changedById?: true
  }

  export type TokenHistoryMaxAggregateInputType = {
    id?: true
    version?: true
    changedAt?: true
    approvedAt?: true
    tokenId?: true
    changedById?: true
  }

  export type TokenHistoryCountAggregateInputType = {
    id?: true
    version?: true
    changes?: true
    changedAt?: true
    approvedAt?: true
    rollbackInfo?: true
    tokenId?: true
    changedById?: true
    _all?: true
  }

  export type TokenHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenHistory to aggregate.
     */
    where?: TokenHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHistories to fetch.
     */
    orderBy?: TokenHistoryOrderByWithRelationInput | TokenHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenHistories
    **/
    _count?: true | TokenHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenHistoryMaxAggregateInputType
  }

  export type GetTokenHistoryAggregateType<T extends TokenHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenHistory[P]>
      : GetScalarType<T[P], AggregateTokenHistory[P]>
  }




  export type TokenHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenHistoryWhereInput
    orderBy?: TokenHistoryOrderByWithAggregationInput | TokenHistoryOrderByWithAggregationInput[]
    by: TokenHistoryScalarFieldEnum[] | TokenHistoryScalarFieldEnum
    having?: TokenHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenHistoryCountAggregateInputType | true
    _min?: TokenHistoryMinAggregateInputType
    _max?: TokenHistoryMaxAggregateInputType
  }

  export type TokenHistoryGroupByOutputType = {
    id: string
    version: string
    changes: JsonValue
    changedAt: Date
    approvedAt: Date | null
    rollbackInfo: JsonValue | null
    tokenId: string
    changedById: string
    _count: TokenHistoryCountAggregateOutputType | null
    _min: TokenHistoryMinAggregateOutputType | null
    _max: TokenHistoryMaxAggregateOutputType | null
  }

  type GetTokenHistoryGroupByPayload<T extends TokenHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], TokenHistoryGroupByOutputType[P]>
        }
      >
    >


  export type TokenHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    changes?: boolean
    changedAt?: boolean
    approvedAt?: boolean
    rollbackInfo?: boolean
    tokenId?: boolean
    changedById?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenHistory"]>

  export type TokenHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    changes?: boolean
    changedAt?: boolean
    approvedAt?: boolean
    rollbackInfo?: boolean
    tokenId?: boolean
    changedById?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenHistory"]>

  export type TokenHistorySelectScalar = {
    id?: boolean
    version?: boolean
    changes?: boolean
    changedAt?: boolean
    approvedAt?: boolean
    rollbackInfo?: boolean
    tokenId?: boolean
    changedById?: boolean
  }

  export type TokenHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TokenHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenHistory"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      changes: Prisma.JsonValue
      changedAt: Date
      approvedAt: Date | null
      rollbackInfo: Prisma.JsonValue | null
      tokenId: string
      changedById: string
    }, ExtArgs["result"]["tokenHistory"]>
    composites: {}
  }

  type TokenHistoryGetPayload<S extends boolean | null | undefined | TokenHistoryDefaultArgs> = $Result.GetResult<Prisma.$TokenHistoryPayload, S>

  type TokenHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenHistoryCountAggregateInputType | true
    }

  export interface TokenHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenHistory'], meta: { name: 'TokenHistory' } }
    /**
     * Find zero or one TokenHistory that matches the filter.
     * @param {TokenHistoryFindUniqueArgs} args - Arguments to find a TokenHistory
     * @example
     * // Get one TokenHistory
     * const tokenHistory = await prisma.tokenHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenHistoryFindUniqueArgs>(args: SelectSubset<T, TokenHistoryFindUniqueArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenHistoryFindUniqueOrThrowArgs} args - Arguments to find a TokenHistory
     * @example
     * // Get one TokenHistory
     * const tokenHistory = await prisma.tokenHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryFindFirstArgs} args - Arguments to find a TokenHistory
     * @example
     * // Get one TokenHistory
     * const tokenHistory = await prisma.tokenHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenHistoryFindFirstArgs>(args?: SelectSubset<T, TokenHistoryFindFirstArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryFindFirstOrThrowArgs} args - Arguments to find a TokenHistory
     * @example
     * // Get one TokenHistory
     * const tokenHistory = await prisma.tokenHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenHistories
     * const tokenHistories = await prisma.tokenHistory.findMany()
     * 
     * // Get first 10 TokenHistories
     * const tokenHistories = await prisma.tokenHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenHistoryWithIdOnly = await prisma.tokenHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenHistoryFindManyArgs>(args?: SelectSubset<T, TokenHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenHistory.
     * @param {TokenHistoryCreateArgs} args - Arguments to create a TokenHistory.
     * @example
     * // Create one TokenHistory
     * const TokenHistory = await prisma.tokenHistory.create({
     *   data: {
     *     // ... data to create a TokenHistory
     *   }
     * })
     * 
     */
    create<T extends TokenHistoryCreateArgs>(args: SelectSubset<T, TokenHistoryCreateArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenHistories.
     * @param {TokenHistoryCreateManyArgs} args - Arguments to create many TokenHistories.
     * @example
     * // Create many TokenHistories
     * const tokenHistory = await prisma.tokenHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenHistoryCreateManyArgs>(args?: SelectSubset<T, TokenHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenHistories and returns the data saved in the database.
     * @param {TokenHistoryCreateManyAndReturnArgs} args - Arguments to create many TokenHistories.
     * @example
     * // Create many TokenHistories
     * const tokenHistory = await prisma.tokenHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenHistories and only return the `id`
     * const tokenHistoryWithIdOnly = await prisma.tokenHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenHistory.
     * @param {TokenHistoryDeleteArgs} args - Arguments to delete one TokenHistory.
     * @example
     * // Delete one TokenHistory
     * const TokenHistory = await prisma.tokenHistory.delete({
     *   where: {
     *     // ... filter to delete one TokenHistory
     *   }
     * })
     * 
     */
    delete<T extends TokenHistoryDeleteArgs>(args: SelectSubset<T, TokenHistoryDeleteArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenHistory.
     * @param {TokenHistoryUpdateArgs} args - Arguments to update one TokenHistory.
     * @example
     * // Update one TokenHistory
     * const tokenHistory = await prisma.tokenHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenHistoryUpdateArgs>(args: SelectSubset<T, TokenHistoryUpdateArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenHistories.
     * @param {TokenHistoryDeleteManyArgs} args - Arguments to filter TokenHistories to delete.
     * @example
     * // Delete a few TokenHistories
     * const { count } = await prisma.tokenHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenHistoryDeleteManyArgs>(args?: SelectSubset<T, TokenHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenHistories
     * const tokenHistory = await prisma.tokenHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenHistoryUpdateManyArgs>(args: SelectSubset<T, TokenHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenHistory.
     * @param {TokenHistoryUpsertArgs} args - Arguments to update or create a TokenHistory.
     * @example
     * // Update or create a TokenHistory
     * const tokenHistory = await prisma.tokenHistory.upsert({
     *   create: {
     *     // ... data to create a TokenHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenHistory we want to update
     *   }
     * })
     */
    upsert<T extends TokenHistoryUpsertArgs>(args: SelectSubset<T, TokenHistoryUpsertArgs<ExtArgs>>): Prisma__TokenHistoryClient<$Result.GetResult<Prisma.$TokenHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryCountArgs} args - Arguments to filter TokenHistories to count.
     * @example
     * // Count the number of TokenHistories
     * const count = await prisma.tokenHistory.count({
     *   where: {
     *     // ... the filter for the TokenHistories we want to count
     *   }
     * })
    **/
    count<T extends TokenHistoryCountArgs>(
      args?: Subset<T, TokenHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenHistoryAggregateArgs>(args: Subset<T, TokenHistoryAggregateArgs>): Prisma.PrismaPromise<GetTokenHistoryAggregateType<T>>

    /**
     * Group by TokenHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenHistoryGroupByArgs['orderBy'] }
        : { orderBy?: TokenHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenHistory model
   */
  readonly fields: TokenHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenHistory model
   */ 
  interface TokenHistoryFieldRefs {
    readonly id: FieldRef<"TokenHistory", 'String'>
    readonly version: FieldRef<"TokenHistory", 'String'>
    readonly changes: FieldRef<"TokenHistory", 'Json'>
    readonly changedAt: FieldRef<"TokenHistory", 'DateTime'>
    readonly approvedAt: FieldRef<"TokenHistory", 'DateTime'>
    readonly rollbackInfo: FieldRef<"TokenHistory", 'Json'>
    readonly tokenId: FieldRef<"TokenHistory", 'String'>
    readonly changedById: FieldRef<"TokenHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TokenHistory findUnique
   */
  export type TokenHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TokenHistory to fetch.
     */
    where: TokenHistoryWhereUniqueInput
  }

  /**
   * TokenHistory findUniqueOrThrow
   */
  export type TokenHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TokenHistory to fetch.
     */
    where: TokenHistoryWhereUniqueInput
  }

  /**
   * TokenHistory findFirst
   */
  export type TokenHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TokenHistory to fetch.
     */
    where?: TokenHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHistories to fetch.
     */
    orderBy?: TokenHistoryOrderByWithRelationInput | TokenHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenHistories.
     */
    cursor?: TokenHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenHistories.
     */
    distinct?: TokenHistoryScalarFieldEnum | TokenHistoryScalarFieldEnum[]
  }

  /**
   * TokenHistory findFirstOrThrow
   */
  export type TokenHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TokenHistory to fetch.
     */
    where?: TokenHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHistories to fetch.
     */
    orderBy?: TokenHistoryOrderByWithRelationInput | TokenHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenHistories.
     */
    cursor?: TokenHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenHistories.
     */
    distinct?: TokenHistoryScalarFieldEnum | TokenHistoryScalarFieldEnum[]
  }

  /**
   * TokenHistory findMany
   */
  export type TokenHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * Filter, which TokenHistories to fetch.
     */
    where?: TokenHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHistories to fetch.
     */
    orderBy?: TokenHistoryOrderByWithRelationInput | TokenHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenHistories.
     */
    cursor?: TokenHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHistories.
     */
    skip?: number
    distinct?: TokenHistoryScalarFieldEnum | TokenHistoryScalarFieldEnum[]
  }

  /**
   * TokenHistory create
   */
  export type TokenHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenHistory.
     */
    data: XOR<TokenHistoryCreateInput, TokenHistoryUncheckedCreateInput>
  }

  /**
   * TokenHistory createMany
   */
  export type TokenHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenHistories.
     */
    data: TokenHistoryCreateManyInput | TokenHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenHistory createManyAndReturn
   */
  export type TokenHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenHistories.
     */
    data: TokenHistoryCreateManyInput | TokenHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenHistory update
   */
  export type TokenHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenHistory.
     */
    data: XOR<TokenHistoryUpdateInput, TokenHistoryUncheckedUpdateInput>
    /**
     * Choose, which TokenHistory to update.
     */
    where: TokenHistoryWhereUniqueInput
  }

  /**
   * TokenHistory updateMany
   */
  export type TokenHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenHistories.
     */
    data: XOR<TokenHistoryUpdateManyMutationInput, TokenHistoryUncheckedUpdateManyInput>
    /**
     * Filter which TokenHistories to update
     */
    where?: TokenHistoryWhereInput
  }

  /**
   * TokenHistory upsert
   */
  export type TokenHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenHistory to update in case it exists.
     */
    where: TokenHistoryWhereUniqueInput
    /**
     * In case the TokenHistory found by the `where` argument doesn't exist, create a new TokenHistory with this data.
     */
    create: XOR<TokenHistoryCreateInput, TokenHistoryUncheckedCreateInput>
    /**
     * In case the TokenHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenHistoryUpdateInput, TokenHistoryUncheckedUpdateInput>
  }

  /**
   * TokenHistory delete
   */
  export type TokenHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
    /**
     * Filter which TokenHistory to delete.
     */
    where: TokenHistoryWhereUniqueInput
  }

  /**
   * TokenHistory deleteMany
   */
  export type TokenHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenHistories to delete
     */
    where?: TokenHistoryWhereInput
  }

  /**
   * TokenHistory without action
   */
  export type TokenHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHistory
     */
    select?: TokenHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactEmail: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactEmail: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    contactEmail: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    contactEmail?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    contactEmail?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    contactEmail?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    contactEmail: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactEmail?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applications?: boolean | Team$applicationsArgs<ExtArgs>
    tokenUsages?: boolean | Team$tokenUsagesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactEmail?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    contactEmail?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Team$applicationsArgs<ExtArgs>
    tokenUsages?: boolean | Team$tokenUsagesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
      tokenUsages: Prisma.$TokenUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactEmail: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends Team$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    tokenUsages<T extends Team$tokenUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Team$tokenUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly contactEmail: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly isActive: FieldRef<"Team", 'Boolean'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.applications
   */
  export type Team$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Team.tokenUsages
   */
  export type Team$tokenUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    where?: TokenUsageWhereInput
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    cursor?: TokenUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenUsageScalarFieldEnum | TokenUsageScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AppType | null
    domain: string | null
    repository: string | null
    status: $Enums.AppStatus | null
    lastScanned: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AppType | null
    domain: string | null
    repository: string | null
    status: $Enums.AppStatus | null
    lastScanned: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    domain: number
    repository: number
    status: number
    lastScanned: number
    createdAt: number
    updatedAt: number
    teamId: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    domain?: true
    repository?: true
    status?: true
    lastScanned?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    domain?: true
    repository?: true
    status?: true
    lastScanned?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    domain?: true
    repository?: true
    status?: true
    lastScanned?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    name: string
    type: $Enums.AppType
    domain: string | null
    repository: string | null
    status: $Enums.AppStatus
    lastScanned: Date | null
    createdAt: Date
    updatedAt: Date
    teamId: string
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    domain?: boolean
    repository?: boolean
    status?: boolean
    lastScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    tokenUsages?: boolean | Application$tokenUsagesArgs<ExtArgs>
    scanResults?: boolean | Application$scanResultsArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    domain?: boolean
    repository?: boolean
    status?: boolean
    lastScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    domain?: boolean
    repository?: boolean
    status?: boolean
    lastScanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
  }

  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    tokenUsages?: boolean | Application$tokenUsagesArgs<ExtArgs>
    scanResults?: boolean | Application$scanResultsArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      tokenUsages: Prisma.$TokenUsagePayload<ExtArgs>[]
      scanResults: Prisma.$ScanResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.AppType
      domain: string | null
      repository: string | null
      status: $Enums.AppStatus
      lastScanned: Date | null
      createdAt: Date
      updatedAt: Date
      teamId: string
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tokenUsages<T extends Application$tokenUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Application$tokenUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findMany"> | Null>
    scanResults<T extends Application$scanResultsArgs<ExtArgs> = {}>(args?: Subset<T, Application$scanResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */ 
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly name: FieldRef<"Application", 'String'>
    readonly type: FieldRef<"Application", 'AppType'>
    readonly domain: FieldRef<"Application", 'String'>
    readonly repository: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'AppStatus'>
    readonly lastScanned: FieldRef<"Application", 'DateTime'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
    readonly teamId: FieldRef<"Application", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application.tokenUsages
   */
  export type Application$tokenUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    where?: TokenUsageWhereInput
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    cursor?: TokenUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenUsageScalarFieldEnum | TokenUsageScalarFieldEnum[]
  }

  /**
   * Application.scanResults
   */
  export type Application$scanResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    where?: ScanResultWhereInput
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    cursor?: ScanResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model TokenUsage
   */

  export type AggregateTokenUsage = {
    _count: TokenUsageCountAggregateOutputType | null
    _avg: TokenUsageAvgAggregateOutputType | null
    _sum: TokenUsageSumAggregateOutputType | null
    _min: TokenUsageMinAggregateOutputType | null
    _max: TokenUsageMaxAggregateOutputType | null
  }

  export type TokenUsageAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type TokenUsageSumAggregateOutputType = {
    usageCount: number | null
  }

  export type TokenUsageMinAggregateOutputType = {
    id: string | null
    usageCount: number | null
    lastUsed: Date | null
    implementation: $Enums.Implementation | null
    createdAt: Date | null
    updatedAt: Date | null
    tokenId: string | null
    teamId: string | null
    applicationId: string | null
  }

  export type TokenUsageMaxAggregateOutputType = {
    id: string | null
    usageCount: number | null
    lastUsed: Date | null
    implementation: $Enums.Implementation | null
    createdAt: Date | null
    updatedAt: Date | null
    tokenId: string | null
    teamId: string | null
    applicationId: string | null
  }

  export type TokenUsageCountAggregateOutputType = {
    id: number
    usageCount: number
    lastUsed: number
    implementation: number
    filePaths: number
    createdAt: number
    updatedAt: number
    tokenId: number
    teamId: number
    applicationId: number
    _all: number
  }


  export type TokenUsageAvgAggregateInputType = {
    usageCount?: true
  }

  export type TokenUsageSumAggregateInputType = {
    usageCount?: true
  }

  export type TokenUsageMinAggregateInputType = {
    id?: true
    usageCount?: true
    lastUsed?: true
    implementation?: true
    createdAt?: true
    updatedAt?: true
    tokenId?: true
    teamId?: true
    applicationId?: true
  }

  export type TokenUsageMaxAggregateInputType = {
    id?: true
    usageCount?: true
    lastUsed?: true
    implementation?: true
    createdAt?: true
    updatedAt?: true
    tokenId?: true
    teamId?: true
    applicationId?: true
  }

  export type TokenUsageCountAggregateInputType = {
    id?: true
    usageCount?: true
    lastUsed?: true
    implementation?: true
    filePaths?: true
    createdAt?: true
    updatedAt?: true
    tokenId?: true
    teamId?: true
    applicationId?: true
    _all?: true
  }

  export type TokenUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenUsage to aggregate.
     */
    where?: TokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenUsages to fetch.
     */
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenUsages
    **/
    _count?: true | TokenUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenUsageMaxAggregateInputType
  }

  export type GetTokenUsageAggregateType<T extends TokenUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenUsage[P]>
      : GetScalarType<T[P], AggregateTokenUsage[P]>
  }




  export type TokenUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenUsageWhereInput
    orderBy?: TokenUsageOrderByWithAggregationInput | TokenUsageOrderByWithAggregationInput[]
    by: TokenUsageScalarFieldEnum[] | TokenUsageScalarFieldEnum
    having?: TokenUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenUsageCountAggregateInputType | true
    _avg?: TokenUsageAvgAggregateInputType
    _sum?: TokenUsageSumAggregateInputType
    _min?: TokenUsageMinAggregateInputType
    _max?: TokenUsageMaxAggregateInputType
  }

  export type TokenUsageGroupByOutputType = {
    id: string
    usageCount: number
    lastUsed: Date
    implementation: $Enums.Implementation
    filePaths: string[]
    createdAt: Date
    updatedAt: Date
    tokenId: string
    teamId: string
    applicationId: string
    _count: TokenUsageCountAggregateOutputType | null
    _avg: TokenUsageAvgAggregateOutputType | null
    _sum: TokenUsageSumAggregateOutputType | null
    _min: TokenUsageMinAggregateOutputType | null
    _max: TokenUsageMaxAggregateOutputType | null
  }

  type GetTokenUsageGroupByPayload<T extends TokenUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenUsageGroupByOutputType[P]>
            : GetScalarType<T[P], TokenUsageGroupByOutputType[P]>
        }
      >
    >


  export type TokenUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usageCount?: boolean
    lastUsed?: boolean
    implementation?: boolean
    filePaths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokenId?: boolean
    teamId?: boolean
    applicationId?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenUsage"]>

  export type TokenUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usageCount?: boolean
    lastUsed?: boolean
    implementation?: boolean
    filePaths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokenId?: boolean
    teamId?: boolean
    applicationId?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenUsage"]>

  export type TokenUsageSelectScalar = {
    id?: boolean
    usageCount?: boolean
    lastUsed?: boolean
    implementation?: boolean
    filePaths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokenId?: boolean
    teamId?: boolean
    applicationId?: boolean
  }

  export type TokenUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type TokenUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $TokenUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenUsage"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usageCount: number
      lastUsed: Date
      implementation: $Enums.Implementation
      filePaths: string[]
      createdAt: Date
      updatedAt: Date
      tokenId: string
      teamId: string
      applicationId: string
    }, ExtArgs["result"]["tokenUsage"]>
    composites: {}
  }

  type TokenUsageGetPayload<S extends boolean | null | undefined | TokenUsageDefaultArgs> = $Result.GetResult<Prisma.$TokenUsagePayload, S>

  type TokenUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenUsageCountAggregateInputType | true
    }

  export interface TokenUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenUsage'], meta: { name: 'TokenUsage' } }
    /**
     * Find zero or one TokenUsage that matches the filter.
     * @param {TokenUsageFindUniqueArgs} args - Arguments to find a TokenUsage
     * @example
     * // Get one TokenUsage
     * const tokenUsage = await prisma.tokenUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenUsageFindUniqueArgs>(args: SelectSubset<T, TokenUsageFindUniqueArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenUsageFindUniqueOrThrowArgs} args - Arguments to find a TokenUsage
     * @example
     * // Get one TokenUsage
     * const tokenUsage = await prisma.tokenUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageFindFirstArgs} args - Arguments to find a TokenUsage
     * @example
     * // Get one TokenUsage
     * const tokenUsage = await prisma.tokenUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenUsageFindFirstArgs>(args?: SelectSubset<T, TokenUsageFindFirstArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageFindFirstOrThrowArgs} args - Arguments to find a TokenUsage
     * @example
     * // Get one TokenUsage
     * const tokenUsage = await prisma.tokenUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenUsages
     * const tokenUsages = await prisma.tokenUsage.findMany()
     * 
     * // Get first 10 TokenUsages
     * const tokenUsages = await prisma.tokenUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenUsageWithIdOnly = await prisma.tokenUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenUsageFindManyArgs>(args?: SelectSubset<T, TokenUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenUsage.
     * @param {TokenUsageCreateArgs} args - Arguments to create a TokenUsage.
     * @example
     * // Create one TokenUsage
     * const TokenUsage = await prisma.tokenUsage.create({
     *   data: {
     *     // ... data to create a TokenUsage
     *   }
     * })
     * 
     */
    create<T extends TokenUsageCreateArgs>(args: SelectSubset<T, TokenUsageCreateArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenUsages.
     * @param {TokenUsageCreateManyArgs} args - Arguments to create many TokenUsages.
     * @example
     * // Create many TokenUsages
     * const tokenUsage = await prisma.tokenUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenUsageCreateManyArgs>(args?: SelectSubset<T, TokenUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenUsages and returns the data saved in the database.
     * @param {TokenUsageCreateManyAndReturnArgs} args - Arguments to create many TokenUsages.
     * @example
     * // Create many TokenUsages
     * const tokenUsage = await prisma.tokenUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenUsages and only return the `id`
     * const tokenUsageWithIdOnly = await prisma.tokenUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenUsage.
     * @param {TokenUsageDeleteArgs} args - Arguments to delete one TokenUsage.
     * @example
     * // Delete one TokenUsage
     * const TokenUsage = await prisma.tokenUsage.delete({
     *   where: {
     *     // ... filter to delete one TokenUsage
     *   }
     * })
     * 
     */
    delete<T extends TokenUsageDeleteArgs>(args: SelectSubset<T, TokenUsageDeleteArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenUsage.
     * @param {TokenUsageUpdateArgs} args - Arguments to update one TokenUsage.
     * @example
     * // Update one TokenUsage
     * const tokenUsage = await prisma.tokenUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUsageUpdateArgs>(args: SelectSubset<T, TokenUsageUpdateArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenUsages.
     * @param {TokenUsageDeleteManyArgs} args - Arguments to filter TokenUsages to delete.
     * @example
     * // Delete a few TokenUsages
     * const { count } = await prisma.tokenUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenUsageDeleteManyArgs>(args?: SelectSubset<T, TokenUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenUsages
     * const tokenUsage = await prisma.tokenUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUsageUpdateManyArgs>(args: SelectSubset<T, TokenUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenUsage.
     * @param {TokenUsageUpsertArgs} args - Arguments to update or create a TokenUsage.
     * @example
     * // Update or create a TokenUsage
     * const tokenUsage = await prisma.tokenUsage.upsert({
     *   create: {
     *     // ... data to create a TokenUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenUsage we want to update
     *   }
     * })
     */
    upsert<T extends TokenUsageUpsertArgs>(args: SelectSubset<T, TokenUsageUpsertArgs<ExtArgs>>): Prisma__TokenUsageClient<$Result.GetResult<Prisma.$TokenUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageCountArgs} args - Arguments to filter TokenUsages to count.
     * @example
     * // Count the number of TokenUsages
     * const count = await prisma.tokenUsage.count({
     *   where: {
     *     // ... the filter for the TokenUsages we want to count
     *   }
     * })
    **/
    count<T extends TokenUsageCountArgs>(
      args?: Subset<T, TokenUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenUsageAggregateArgs>(args: Subset<T, TokenUsageAggregateArgs>): Prisma.PrismaPromise<GetTokenUsageAggregateType<T>>

    /**
     * Group by TokenUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenUsageGroupByArgs['orderBy'] }
        : { orderBy?: TokenUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenUsage model
   */
  readonly fields: TokenUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenUsage model
   */ 
  interface TokenUsageFieldRefs {
    readonly id: FieldRef<"TokenUsage", 'String'>
    readonly usageCount: FieldRef<"TokenUsage", 'Int'>
    readonly lastUsed: FieldRef<"TokenUsage", 'DateTime'>
    readonly implementation: FieldRef<"TokenUsage", 'Implementation'>
    readonly filePaths: FieldRef<"TokenUsage", 'String[]'>
    readonly createdAt: FieldRef<"TokenUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"TokenUsage", 'DateTime'>
    readonly tokenId: FieldRef<"TokenUsage", 'String'>
    readonly teamId: FieldRef<"TokenUsage", 'String'>
    readonly applicationId: FieldRef<"TokenUsage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TokenUsage findUnique
   */
  export type TokenUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which TokenUsage to fetch.
     */
    where: TokenUsageWhereUniqueInput
  }

  /**
   * TokenUsage findUniqueOrThrow
   */
  export type TokenUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which TokenUsage to fetch.
     */
    where: TokenUsageWhereUniqueInput
  }

  /**
   * TokenUsage findFirst
   */
  export type TokenUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which TokenUsage to fetch.
     */
    where?: TokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenUsages to fetch.
     */
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenUsages.
     */
    cursor?: TokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenUsages.
     */
    distinct?: TokenUsageScalarFieldEnum | TokenUsageScalarFieldEnum[]
  }

  /**
   * TokenUsage findFirstOrThrow
   */
  export type TokenUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which TokenUsage to fetch.
     */
    where?: TokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenUsages to fetch.
     */
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenUsages.
     */
    cursor?: TokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenUsages.
     */
    distinct?: TokenUsageScalarFieldEnum | TokenUsageScalarFieldEnum[]
  }

  /**
   * TokenUsage findMany
   */
  export type TokenUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * Filter, which TokenUsages to fetch.
     */
    where?: TokenUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenUsages to fetch.
     */
    orderBy?: TokenUsageOrderByWithRelationInput | TokenUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenUsages.
     */
    cursor?: TokenUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenUsages.
     */
    skip?: number
    distinct?: TokenUsageScalarFieldEnum | TokenUsageScalarFieldEnum[]
  }

  /**
   * TokenUsage create
   */
  export type TokenUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenUsage.
     */
    data: XOR<TokenUsageCreateInput, TokenUsageUncheckedCreateInput>
  }

  /**
   * TokenUsage createMany
   */
  export type TokenUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenUsages.
     */
    data: TokenUsageCreateManyInput | TokenUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenUsage createManyAndReturn
   */
  export type TokenUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenUsages.
     */
    data: TokenUsageCreateManyInput | TokenUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenUsage update
   */
  export type TokenUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenUsage.
     */
    data: XOR<TokenUsageUpdateInput, TokenUsageUncheckedUpdateInput>
    /**
     * Choose, which TokenUsage to update.
     */
    where: TokenUsageWhereUniqueInput
  }

  /**
   * TokenUsage updateMany
   */
  export type TokenUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenUsages.
     */
    data: XOR<TokenUsageUpdateManyMutationInput, TokenUsageUncheckedUpdateManyInput>
    /**
     * Filter which TokenUsages to update
     */
    where?: TokenUsageWhereInput
  }

  /**
   * TokenUsage upsert
   */
  export type TokenUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenUsage to update in case it exists.
     */
    where: TokenUsageWhereUniqueInput
    /**
     * In case the TokenUsage found by the `where` argument doesn't exist, create a new TokenUsage with this data.
     */
    create: XOR<TokenUsageCreateInput, TokenUsageUncheckedCreateInput>
    /**
     * In case the TokenUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUsageUpdateInput, TokenUsageUncheckedUpdateInput>
  }

  /**
   * TokenUsage delete
   */
  export type TokenUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
    /**
     * Filter which TokenUsage to delete.
     */
    where: TokenUsageWhereUniqueInput
  }

  /**
   * TokenUsage deleteMany
   */
  export type TokenUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenUsages to delete
     */
    where?: TokenUsageWhereInput
  }

  /**
   * TokenUsage without action
   */
  export type TokenUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenUsage
     */
    select?: TokenUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenUsageInclude<ExtArgs> | null
  }


  /**
   * Model Pattern
   */

  export type AggregatePattern = {
    _count: PatternCountAggregateOutputType | null
    _min: PatternMinAggregateOutputType | null
    _max: PatternMaxAggregateOutputType | null
  }

  export type PatternMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    name: string | null
    description: string | null
    complexity: $Enums.Complexity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatternMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    name: string | null
    description: string | null
    complexity: $Enums.Complexity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatternCountAggregateOutputType = {
    id: number
    patternId: number
    name: number
    description: number
    complexity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatternMinAggregateInputType = {
    id?: true
    patternId?: true
    name?: true
    description?: true
    complexity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatternMaxAggregateInputType = {
    id?: true
    patternId?: true
    name?: true
    description?: true
    complexity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatternCountAggregateInputType = {
    id?: true
    patternId?: true
    name?: true
    description?: true
    complexity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pattern to aggregate.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patterns
    **/
    _count?: true | PatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatternMaxAggregateInputType
  }

  export type GetPatternAggregateType<T extends PatternAggregateArgs> = {
        [P in keyof T & keyof AggregatePattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePattern[P]>
      : GetScalarType<T[P], AggregatePattern[P]>
  }




  export type PatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternWhereInput
    orderBy?: PatternOrderByWithAggregationInput | PatternOrderByWithAggregationInput[]
    by: PatternScalarFieldEnum[] | PatternScalarFieldEnum
    having?: PatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternCountAggregateInputType | true
    _min?: PatternMinAggregateInputType
    _max?: PatternMaxAggregateInputType
  }

  export type PatternGroupByOutputType = {
    id: string
    patternId: string
    name: string
    description: string | null
    complexity: $Enums.Complexity
    createdAt: Date
    updatedAt: Date
    _count: PatternCountAggregateOutputType | null
    _min: PatternMinAggregateOutputType | null
    _max: PatternMaxAggregateOutputType | null
  }

  type GetPatternGroupByPayload<T extends PatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternGroupByOutputType[P]>
            : GetScalarType<T[P], PatternGroupByOutputType[P]>
        }
      >
    >


  export type PatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    name?: boolean
    description?: boolean
    complexity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokens?: boolean | Pattern$tokensArgs<ExtArgs>
    usages?: boolean | Pattern$usagesArgs<ExtArgs>
    _count?: boolean | PatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pattern"]>

  export type PatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    name?: boolean
    description?: boolean
    complexity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pattern"]>

  export type PatternSelectScalar = {
    id?: boolean
    patternId?: boolean
    name?: boolean
    description?: boolean
    complexity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | Pattern$tokensArgs<ExtArgs>
    usages?: boolean | Pattern$usagesArgs<ExtArgs>
    _count?: boolean | PatternCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pattern"
    objects: {
      tokens: Prisma.$PatternTokenPayload<ExtArgs>[]
      usages: Prisma.$PatternUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      name: string
      description: string | null
      complexity: $Enums.Complexity
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pattern"]>
    composites: {}
  }

  type PatternGetPayload<S extends boolean | null | undefined | PatternDefaultArgs> = $Result.GetResult<Prisma.$PatternPayload, S>

  type PatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatternCountAggregateInputType | true
    }

  export interface PatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pattern'], meta: { name: 'Pattern' } }
    /**
     * Find zero or one Pattern that matches the filter.
     * @param {PatternFindUniqueArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternFindUniqueArgs>(args: SelectSubset<T, PatternFindUniqueArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatternFindUniqueOrThrowArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternFindFirstArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternFindFirstArgs>(args?: SelectSubset<T, PatternFindFirstArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternFindFirstOrThrowArgs} args - Arguments to find a Pattern
     * @example
     * // Get one Pattern
     * const pattern = await prisma.pattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patterns
     * const patterns = await prisma.pattern.findMany()
     * 
     * // Get first 10 Patterns
     * const patterns = await prisma.pattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patternWithIdOnly = await prisma.pattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatternFindManyArgs>(args?: SelectSubset<T, PatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pattern.
     * @param {PatternCreateArgs} args - Arguments to create a Pattern.
     * @example
     * // Create one Pattern
     * const Pattern = await prisma.pattern.create({
     *   data: {
     *     // ... data to create a Pattern
     *   }
     * })
     * 
     */
    create<T extends PatternCreateArgs>(args: SelectSubset<T, PatternCreateArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patterns.
     * @param {PatternCreateManyArgs} args - Arguments to create many Patterns.
     * @example
     * // Create many Patterns
     * const pattern = await prisma.pattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatternCreateManyArgs>(args?: SelectSubset<T, PatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patterns and returns the data saved in the database.
     * @param {PatternCreateManyAndReturnArgs} args - Arguments to create many Patterns.
     * @example
     * // Create many Patterns
     * const pattern = await prisma.pattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patterns and only return the `id`
     * const patternWithIdOnly = await prisma.pattern.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatternCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pattern.
     * @param {PatternDeleteArgs} args - Arguments to delete one Pattern.
     * @example
     * // Delete one Pattern
     * const Pattern = await prisma.pattern.delete({
     *   where: {
     *     // ... filter to delete one Pattern
     *   }
     * })
     * 
     */
    delete<T extends PatternDeleteArgs>(args: SelectSubset<T, PatternDeleteArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pattern.
     * @param {PatternUpdateArgs} args - Arguments to update one Pattern.
     * @example
     * // Update one Pattern
     * const pattern = await prisma.pattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatternUpdateArgs>(args: SelectSubset<T, PatternUpdateArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patterns.
     * @param {PatternDeleteManyArgs} args - Arguments to filter Patterns to delete.
     * @example
     * // Delete a few Patterns
     * const { count } = await prisma.pattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatternDeleteManyArgs>(args?: SelectSubset<T, PatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patterns
     * const pattern = await prisma.pattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatternUpdateManyArgs>(args: SelectSubset<T, PatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pattern.
     * @param {PatternUpsertArgs} args - Arguments to update or create a Pattern.
     * @example
     * // Update or create a Pattern
     * const pattern = await prisma.pattern.upsert({
     *   create: {
     *     // ... data to create a Pattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pattern we want to update
     *   }
     * })
     */
    upsert<T extends PatternUpsertArgs>(args: SelectSubset<T, PatternUpsertArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternCountArgs} args - Arguments to filter Patterns to count.
     * @example
     * // Count the number of Patterns
     * const count = await prisma.pattern.count({
     *   where: {
     *     // ... the filter for the Patterns we want to count
     *   }
     * })
    **/
    count<T extends PatternCountArgs>(
      args?: Subset<T, PatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternAggregateArgs>(args: Subset<T, PatternAggregateArgs>): Prisma.PrismaPromise<GetPatternAggregateType<T>>

    /**
     * Group by Pattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternGroupByArgs['orderBy'] }
        : { orderBy?: PatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pattern model
   */
  readonly fields: PatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tokens<T extends Pattern$tokensArgs<ExtArgs> = {}>(args?: Subset<T, Pattern$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findMany"> | Null>
    usages<T extends Pattern$usagesArgs<ExtArgs> = {}>(args?: Subset<T, Pattern$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pattern model
   */ 
  interface PatternFieldRefs {
    readonly id: FieldRef<"Pattern", 'String'>
    readonly patternId: FieldRef<"Pattern", 'String'>
    readonly name: FieldRef<"Pattern", 'String'>
    readonly description: FieldRef<"Pattern", 'String'>
    readonly complexity: FieldRef<"Pattern", 'Complexity'>
    readonly createdAt: FieldRef<"Pattern", 'DateTime'>
    readonly updatedAt: FieldRef<"Pattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pattern findUnique
   */
  export type PatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern findUniqueOrThrow
   */
  export type PatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern findFirst
   */
  export type PatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patterns.
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patterns.
     */
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * Pattern findFirstOrThrow
   */
  export type PatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Pattern to fetch.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patterns.
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patterns.
     */
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * Pattern findMany
   */
  export type PatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter, which Patterns to fetch.
     */
    where?: PatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patterns to fetch.
     */
    orderBy?: PatternOrderByWithRelationInput | PatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patterns.
     */
    cursor?: PatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patterns.
     */
    skip?: number
    distinct?: PatternScalarFieldEnum | PatternScalarFieldEnum[]
  }

  /**
   * Pattern create
   */
  export type PatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * The data needed to create a Pattern.
     */
    data: XOR<PatternCreateInput, PatternUncheckedCreateInput>
  }

  /**
   * Pattern createMany
   */
  export type PatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patterns.
     */
    data: PatternCreateManyInput | PatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pattern createManyAndReturn
   */
  export type PatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patterns.
     */
    data: PatternCreateManyInput | PatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pattern update
   */
  export type PatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * The data needed to update a Pattern.
     */
    data: XOR<PatternUpdateInput, PatternUncheckedUpdateInput>
    /**
     * Choose, which Pattern to update.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern updateMany
   */
  export type PatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patterns.
     */
    data: XOR<PatternUpdateManyMutationInput, PatternUncheckedUpdateManyInput>
    /**
     * Filter which Patterns to update
     */
    where?: PatternWhereInput
  }

  /**
   * Pattern upsert
   */
  export type PatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * The filter to search for the Pattern to update in case it exists.
     */
    where: PatternWhereUniqueInput
    /**
     * In case the Pattern found by the `where` argument doesn't exist, create a new Pattern with this data.
     */
    create: XOR<PatternCreateInput, PatternUncheckedCreateInput>
    /**
     * In case the Pattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternUpdateInput, PatternUncheckedUpdateInput>
  }

  /**
   * Pattern delete
   */
  export type PatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
    /**
     * Filter which Pattern to delete.
     */
    where: PatternWhereUniqueInput
  }

  /**
   * Pattern deleteMany
   */
  export type PatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patterns to delete
     */
    where?: PatternWhereInput
  }

  /**
   * Pattern.tokens
   */
  export type Pattern$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    where?: PatternTokenWhereInput
    orderBy?: PatternTokenOrderByWithRelationInput | PatternTokenOrderByWithRelationInput[]
    cursor?: PatternTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternTokenScalarFieldEnum | PatternTokenScalarFieldEnum[]
  }

  /**
   * Pattern.usages
   */
  export type Pattern$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    where?: PatternUsageWhereInput
    orderBy?: PatternUsageOrderByWithRelationInput | PatternUsageOrderByWithRelationInput[]
    cursor?: PatternUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternUsageScalarFieldEnum | PatternUsageScalarFieldEnum[]
  }

  /**
   * Pattern without action
   */
  export type PatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pattern
     */
    select?: PatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternInclude<ExtArgs> | null
  }


  /**
   * Model PatternToken
   */

  export type AggregatePatternToken = {
    _count: PatternTokenCountAggregateOutputType | null
    _min: PatternTokenMinAggregateOutputType | null
    _max: PatternTokenMaxAggregateOutputType | null
  }

  export type PatternTokenMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    tokenId: string | null
  }

  export type PatternTokenMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    tokenId: string | null
  }

  export type PatternTokenCountAggregateOutputType = {
    id: number
    patternId: number
    tokenId: number
    _all: number
  }


  export type PatternTokenMinAggregateInputType = {
    id?: true
    patternId?: true
    tokenId?: true
  }

  export type PatternTokenMaxAggregateInputType = {
    id?: true
    patternId?: true
    tokenId?: true
  }

  export type PatternTokenCountAggregateInputType = {
    id?: true
    patternId?: true
    tokenId?: true
    _all?: true
  }

  export type PatternTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternToken to aggregate.
     */
    where?: PatternTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternTokens to fetch.
     */
    orderBy?: PatternTokenOrderByWithRelationInput | PatternTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatternTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatternTokens
    **/
    _count?: true | PatternTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatternTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatternTokenMaxAggregateInputType
  }

  export type GetPatternTokenAggregateType<T extends PatternTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePatternToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatternToken[P]>
      : GetScalarType<T[P], AggregatePatternToken[P]>
  }




  export type PatternTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternTokenWhereInput
    orderBy?: PatternTokenOrderByWithAggregationInput | PatternTokenOrderByWithAggregationInput[]
    by: PatternTokenScalarFieldEnum[] | PatternTokenScalarFieldEnum
    having?: PatternTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternTokenCountAggregateInputType | true
    _min?: PatternTokenMinAggregateInputType
    _max?: PatternTokenMaxAggregateInputType
  }

  export type PatternTokenGroupByOutputType = {
    id: string
    patternId: string
    tokenId: string
    _count: PatternTokenCountAggregateOutputType | null
    _min: PatternTokenMinAggregateOutputType | null
    _max: PatternTokenMaxAggregateOutputType | null
  }

  type GetPatternTokenGroupByPayload<T extends PatternTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PatternTokenGroupByOutputType[P]>
        }
      >
    >


  export type PatternTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    tokenId?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternToken"]>

  export type PatternTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    tokenId?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternToken"]>

  export type PatternTokenSelectScalar = {
    id?: boolean
    patternId?: boolean
    tokenId?: boolean
  }

  export type PatternTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type PatternTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $PatternTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatternToken"
    objects: {
      pattern: Prisma.$PatternPayload<ExtArgs>
      token: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      tokenId: string
    }, ExtArgs["result"]["patternToken"]>
    composites: {}
  }

  type PatternTokenGetPayload<S extends boolean | null | undefined | PatternTokenDefaultArgs> = $Result.GetResult<Prisma.$PatternTokenPayload, S>

  type PatternTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatternTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatternTokenCountAggregateInputType | true
    }

  export interface PatternTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatternToken'], meta: { name: 'PatternToken' } }
    /**
     * Find zero or one PatternToken that matches the filter.
     * @param {PatternTokenFindUniqueArgs} args - Arguments to find a PatternToken
     * @example
     * // Get one PatternToken
     * const patternToken = await prisma.patternToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternTokenFindUniqueArgs>(args: SelectSubset<T, PatternTokenFindUniqueArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatternToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatternTokenFindUniqueOrThrowArgs} args - Arguments to find a PatternToken
     * @example
     * // Get one PatternToken
     * const patternToken = await prisma.patternToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatternToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenFindFirstArgs} args - Arguments to find a PatternToken
     * @example
     * // Get one PatternToken
     * const patternToken = await prisma.patternToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternTokenFindFirstArgs>(args?: SelectSubset<T, PatternTokenFindFirstArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatternToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenFindFirstOrThrowArgs} args - Arguments to find a PatternToken
     * @example
     * // Get one PatternToken
     * const patternToken = await prisma.patternToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatternTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatternTokens
     * const patternTokens = await prisma.patternToken.findMany()
     * 
     * // Get first 10 PatternTokens
     * const patternTokens = await prisma.patternToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patternTokenWithIdOnly = await prisma.patternToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatternTokenFindManyArgs>(args?: SelectSubset<T, PatternTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatternToken.
     * @param {PatternTokenCreateArgs} args - Arguments to create a PatternToken.
     * @example
     * // Create one PatternToken
     * const PatternToken = await prisma.patternToken.create({
     *   data: {
     *     // ... data to create a PatternToken
     *   }
     * })
     * 
     */
    create<T extends PatternTokenCreateArgs>(args: SelectSubset<T, PatternTokenCreateArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatternTokens.
     * @param {PatternTokenCreateManyArgs} args - Arguments to create many PatternTokens.
     * @example
     * // Create many PatternTokens
     * const patternToken = await prisma.patternToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatternTokenCreateManyArgs>(args?: SelectSubset<T, PatternTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatternTokens and returns the data saved in the database.
     * @param {PatternTokenCreateManyAndReturnArgs} args - Arguments to create many PatternTokens.
     * @example
     * // Create many PatternTokens
     * const patternToken = await prisma.patternToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatternTokens and only return the `id`
     * const patternTokenWithIdOnly = await prisma.patternToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatternTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatternToken.
     * @param {PatternTokenDeleteArgs} args - Arguments to delete one PatternToken.
     * @example
     * // Delete one PatternToken
     * const PatternToken = await prisma.patternToken.delete({
     *   where: {
     *     // ... filter to delete one PatternToken
     *   }
     * })
     * 
     */
    delete<T extends PatternTokenDeleteArgs>(args: SelectSubset<T, PatternTokenDeleteArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatternToken.
     * @param {PatternTokenUpdateArgs} args - Arguments to update one PatternToken.
     * @example
     * // Update one PatternToken
     * const patternToken = await prisma.patternToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatternTokenUpdateArgs>(args: SelectSubset<T, PatternTokenUpdateArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatternTokens.
     * @param {PatternTokenDeleteManyArgs} args - Arguments to filter PatternTokens to delete.
     * @example
     * // Delete a few PatternTokens
     * const { count } = await prisma.patternToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatternTokenDeleteManyArgs>(args?: SelectSubset<T, PatternTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatternTokens
     * const patternToken = await prisma.patternToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatternTokenUpdateManyArgs>(args: SelectSubset<T, PatternTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatternToken.
     * @param {PatternTokenUpsertArgs} args - Arguments to update or create a PatternToken.
     * @example
     * // Update or create a PatternToken
     * const patternToken = await prisma.patternToken.upsert({
     *   create: {
     *     // ... data to create a PatternToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatternToken we want to update
     *   }
     * })
     */
    upsert<T extends PatternTokenUpsertArgs>(args: SelectSubset<T, PatternTokenUpsertArgs<ExtArgs>>): Prisma__PatternTokenClient<$Result.GetResult<Prisma.$PatternTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatternTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenCountArgs} args - Arguments to filter PatternTokens to count.
     * @example
     * // Count the number of PatternTokens
     * const count = await prisma.patternToken.count({
     *   where: {
     *     // ... the filter for the PatternTokens we want to count
     *   }
     * })
    **/
    count<T extends PatternTokenCountArgs>(
      args?: Subset<T, PatternTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatternToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternTokenAggregateArgs>(args: Subset<T, PatternTokenAggregateArgs>): Prisma.PrismaPromise<GetPatternTokenAggregateType<T>>

    /**
     * Group by PatternToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatternTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternTokenGroupByArgs['orderBy'] }
        : { orderBy?: PatternTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatternToken model
   */
  readonly fields: PatternTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatternToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends PatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatternDefaultArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatternToken model
   */ 
  interface PatternTokenFieldRefs {
    readonly id: FieldRef<"PatternToken", 'String'>
    readonly patternId: FieldRef<"PatternToken", 'String'>
    readonly tokenId: FieldRef<"PatternToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PatternToken findUnique
   */
  export type PatternTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * Filter, which PatternToken to fetch.
     */
    where: PatternTokenWhereUniqueInput
  }

  /**
   * PatternToken findUniqueOrThrow
   */
  export type PatternTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * Filter, which PatternToken to fetch.
     */
    where: PatternTokenWhereUniqueInput
  }

  /**
   * PatternToken findFirst
   */
  export type PatternTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * Filter, which PatternToken to fetch.
     */
    where?: PatternTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternTokens to fetch.
     */
    orderBy?: PatternTokenOrderByWithRelationInput | PatternTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatternTokens.
     */
    cursor?: PatternTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatternTokens.
     */
    distinct?: PatternTokenScalarFieldEnum | PatternTokenScalarFieldEnum[]
  }

  /**
   * PatternToken findFirstOrThrow
   */
  export type PatternTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * Filter, which PatternToken to fetch.
     */
    where?: PatternTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternTokens to fetch.
     */
    orderBy?: PatternTokenOrderByWithRelationInput | PatternTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatternTokens.
     */
    cursor?: PatternTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatternTokens.
     */
    distinct?: PatternTokenScalarFieldEnum | PatternTokenScalarFieldEnum[]
  }

  /**
   * PatternToken findMany
   */
  export type PatternTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * Filter, which PatternTokens to fetch.
     */
    where?: PatternTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternTokens to fetch.
     */
    orderBy?: PatternTokenOrderByWithRelationInput | PatternTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatternTokens.
     */
    cursor?: PatternTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternTokens.
     */
    skip?: number
    distinct?: PatternTokenScalarFieldEnum | PatternTokenScalarFieldEnum[]
  }

  /**
   * PatternToken create
   */
  export type PatternTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PatternToken.
     */
    data: XOR<PatternTokenCreateInput, PatternTokenUncheckedCreateInput>
  }

  /**
   * PatternToken createMany
   */
  export type PatternTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatternTokens.
     */
    data: PatternTokenCreateManyInput | PatternTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatternToken createManyAndReturn
   */
  export type PatternTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatternTokens.
     */
    data: PatternTokenCreateManyInput | PatternTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternToken update
   */
  export type PatternTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PatternToken.
     */
    data: XOR<PatternTokenUpdateInput, PatternTokenUncheckedUpdateInput>
    /**
     * Choose, which PatternToken to update.
     */
    where: PatternTokenWhereUniqueInput
  }

  /**
   * PatternToken updateMany
   */
  export type PatternTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatternTokens.
     */
    data: XOR<PatternTokenUpdateManyMutationInput, PatternTokenUncheckedUpdateManyInput>
    /**
     * Filter which PatternTokens to update
     */
    where?: PatternTokenWhereInput
  }

  /**
   * PatternToken upsert
   */
  export type PatternTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PatternToken to update in case it exists.
     */
    where: PatternTokenWhereUniqueInput
    /**
     * In case the PatternToken found by the `where` argument doesn't exist, create a new PatternToken with this data.
     */
    create: XOR<PatternTokenCreateInput, PatternTokenUncheckedCreateInput>
    /**
     * In case the PatternToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternTokenUpdateInput, PatternTokenUncheckedUpdateInput>
  }

  /**
   * PatternToken delete
   */
  export type PatternTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
    /**
     * Filter which PatternToken to delete.
     */
    where: PatternTokenWhereUniqueInput
  }

  /**
   * PatternToken deleteMany
   */
  export type PatternTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternTokens to delete
     */
    where?: PatternTokenWhereInput
  }

  /**
   * PatternToken without action
   */
  export type PatternTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternToken
     */
    select?: PatternTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTokenInclude<ExtArgs> | null
  }


  /**
   * Model PatternUsage
   */

  export type AggregatePatternUsage = {
    _count: PatternUsageCountAggregateOutputType | null
    _avg: PatternUsageAvgAggregateOutputType | null
    _sum: PatternUsageSumAggregateOutputType | null
    _min: PatternUsageMinAggregateOutputType | null
    _max: PatternUsageMaxAggregateOutputType | null
  }

  export type PatternUsageAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type PatternUsageSumAggregateOutputType = {
    usageCount: number | null
  }

  export type PatternUsageMinAggregateOutputType = {
    id: string | null
    usageCount: number | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    patternId: string | null
  }

  export type PatternUsageMaxAggregateOutputType = {
    id: string | null
    usageCount: number | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    patternId: string | null
  }

  export type PatternUsageCountAggregateOutputType = {
    id: number
    usageCount: number
    lastUsed: number
    teams: number
    createdAt: number
    updatedAt: number
    patternId: number
    _all: number
  }


  export type PatternUsageAvgAggregateInputType = {
    usageCount?: true
  }

  export type PatternUsageSumAggregateInputType = {
    usageCount?: true
  }

  export type PatternUsageMinAggregateInputType = {
    id?: true
    usageCount?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
    patternId?: true
  }

  export type PatternUsageMaxAggregateInputType = {
    id?: true
    usageCount?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
    patternId?: true
  }

  export type PatternUsageCountAggregateInputType = {
    id?: true
    usageCount?: true
    lastUsed?: true
    teams?: true
    createdAt?: true
    updatedAt?: true
    patternId?: true
    _all?: true
  }

  export type PatternUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternUsage to aggregate.
     */
    where?: PatternUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternUsages to fetch.
     */
    orderBy?: PatternUsageOrderByWithRelationInput | PatternUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatternUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatternUsages
    **/
    _count?: true | PatternUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatternUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatternUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatternUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatternUsageMaxAggregateInputType
  }

  export type GetPatternUsageAggregateType<T extends PatternUsageAggregateArgs> = {
        [P in keyof T & keyof AggregatePatternUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatternUsage[P]>
      : GetScalarType<T[P], AggregatePatternUsage[P]>
  }




  export type PatternUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternUsageWhereInput
    orderBy?: PatternUsageOrderByWithAggregationInput | PatternUsageOrderByWithAggregationInput[]
    by: PatternUsageScalarFieldEnum[] | PatternUsageScalarFieldEnum
    having?: PatternUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternUsageCountAggregateInputType | true
    _avg?: PatternUsageAvgAggregateInputType
    _sum?: PatternUsageSumAggregateInputType
    _min?: PatternUsageMinAggregateInputType
    _max?: PatternUsageMaxAggregateInputType
  }

  export type PatternUsageGroupByOutputType = {
    id: string
    usageCount: number
    lastUsed: Date
    teams: string[]
    createdAt: Date
    updatedAt: Date
    patternId: string
    _count: PatternUsageCountAggregateOutputType | null
    _avg: PatternUsageAvgAggregateOutputType | null
    _sum: PatternUsageSumAggregateOutputType | null
    _min: PatternUsageMinAggregateOutputType | null
    _max: PatternUsageMaxAggregateOutputType | null
  }

  type GetPatternUsageGroupByPayload<T extends PatternUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternUsageGroupByOutputType[P]>
            : GetScalarType<T[P], PatternUsageGroupByOutputType[P]>
        }
      >
    >


  export type PatternUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usageCount?: boolean
    lastUsed?: boolean
    teams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patternId?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternUsage"]>

  export type PatternUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usageCount?: boolean
    lastUsed?: boolean
    teams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patternId?: boolean
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternUsage"]>

  export type PatternUsageSelectScalar = {
    id?: boolean
    usageCount?: boolean
    lastUsed?: boolean
    teams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patternId?: boolean
  }

  export type PatternUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }
  export type PatternUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | PatternDefaultArgs<ExtArgs>
  }

  export type $PatternUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatternUsage"
    objects: {
      pattern: Prisma.$PatternPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usageCount: number
      lastUsed: Date
      teams: string[]
      createdAt: Date
      updatedAt: Date
      patternId: string
    }, ExtArgs["result"]["patternUsage"]>
    composites: {}
  }

  type PatternUsageGetPayload<S extends boolean | null | undefined | PatternUsageDefaultArgs> = $Result.GetResult<Prisma.$PatternUsagePayload, S>

  type PatternUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatternUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatternUsageCountAggregateInputType | true
    }

  export interface PatternUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatternUsage'], meta: { name: 'PatternUsage' } }
    /**
     * Find zero or one PatternUsage that matches the filter.
     * @param {PatternUsageFindUniqueArgs} args - Arguments to find a PatternUsage
     * @example
     * // Get one PatternUsage
     * const patternUsage = await prisma.patternUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternUsageFindUniqueArgs>(args: SelectSubset<T, PatternUsageFindUniqueArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatternUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatternUsageFindUniqueOrThrowArgs} args - Arguments to find a PatternUsage
     * @example
     * // Get one PatternUsage
     * const patternUsage = await prisma.patternUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatternUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageFindFirstArgs} args - Arguments to find a PatternUsage
     * @example
     * // Get one PatternUsage
     * const patternUsage = await prisma.patternUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternUsageFindFirstArgs>(args?: SelectSubset<T, PatternUsageFindFirstArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatternUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageFindFirstOrThrowArgs} args - Arguments to find a PatternUsage
     * @example
     * // Get one PatternUsage
     * const patternUsage = await prisma.patternUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatternUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatternUsages
     * const patternUsages = await prisma.patternUsage.findMany()
     * 
     * // Get first 10 PatternUsages
     * const patternUsages = await prisma.patternUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patternUsageWithIdOnly = await prisma.patternUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatternUsageFindManyArgs>(args?: SelectSubset<T, PatternUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatternUsage.
     * @param {PatternUsageCreateArgs} args - Arguments to create a PatternUsage.
     * @example
     * // Create one PatternUsage
     * const PatternUsage = await prisma.patternUsage.create({
     *   data: {
     *     // ... data to create a PatternUsage
     *   }
     * })
     * 
     */
    create<T extends PatternUsageCreateArgs>(args: SelectSubset<T, PatternUsageCreateArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatternUsages.
     * @param {PatternUsageCreateManyArgs} args - Arguments to create many PatternUsages.
     * @example
     * // Create many PatternUsages
     * const patternUsage = await prisma.patternUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatternUsageCreateManyArgs>(args?: SelectSubset<T, PatternUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatternUsages and returns the data saved in the database.
     * @param {PatternUsageCreateManyAndReturnArgs} args - Arguments to create many PatternUsages.
     * @example
     * // Create many PatternUsages
     * const patternUsage = await prisma.patternUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatternUsages and only return the `id`
     * const patternUsageWithIdOnly = await prisma.patternUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatternUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatternUsage.
     * @param {PatternUsageDeleteArgs} args - Arguments to delete one PatternUsage.
     * @example
     * // Delete one PatternUsage
     * const PatternUsage = await prisma.patternUsage.delete({
     *   where: {
     *     // ... filter to delete one PatternUsage
     *   }
     * })
     * 
     */
    delete<T extends PatternUsageDeleteArgs>(args: SelectSubset<T, PatternUsageDeleteArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatternUsage.
     * @param {PatternUsageUpdateArgs} args - Arguments to update one PatternUsage.
     * @example
     * // Update one PatternUsage
     * const patternUsage = await prisma.patternUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatternUsageUpdateArgs>(args: SelectSubset<T, PatternUsageUpdateArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatternUsages.
     * @param {PatternUsageDeleteManyArgs} args - Arguments to filter PatternUsages to delete.
     * @example
     * // Delete a few PatternUsages
     * const { count } = await prisma.patternUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatternUsageDeleteManyArgs>(args?: SelectSubset<T, PatternUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatternUsages
     * const patternUsage = await prisma.patternUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatternUsageUpdateManyArgs>(args: SelectSubset<T, PatternUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatternUsage.
     * @param {PatternUsageUpsertArgs} args - Arguments to update or create a PatternUsage.
     * @example
     * // Update or create a PatternUsage
     * const patternUsage = await prisma.patternUsage.upsert({
     *   create: {
     *     // ... data to create a PatternUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatternUsage we want to update
     *   }
     * })
     */
    upsert<T extends PatternUsageUpsertArgs>(args: SelectSubset<T, PatternUsageUpsertArgs<ExtArgs>>): Prisma__PatternUsageClient<$Result.GetResult<Prisma.$PatternUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatternUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageCountArgs} args - Arguments to filter PatternUsages to count.
     * @example
     * // Count the number of PatternUsages
     * const count = await prisma.patternUsage.count({
     *   where: {
     *     // ... the filter for the PatternUsages we want to count
     *   }
     * })
    **/
    count<T extends PatternUsageCountArgs>(
      args?: Subset<T, PatternUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatternUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternUsageAggregateArgs>(args: Subset<T, PatternUsageAggregateArgs>): Prisma.PrismaPromise<GetPatternUsageAggregateType<T>>

    /**
     * Group by PatternUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatternUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternUsageGroupByArgs['orderBy'] }
        : { orderBy?: PatternUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatternUsage model
   */
  readonly fields: PatternUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatternUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends PatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatternDefaultArgs<ExtArgs>>): Prisma__PatternClient<$Result.GetResult<Prisma.$PatternPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatternUsage model
   */ 
  interface PatternUsageFieldRefs {
    readonly id: FieldRef<"PatternUsage", 'String'>
    readonly usageCount: FieldRef<"PatternUsage", 'Int'>
    readonly lastUsed: FieldRef<"PatternUsage", 'DateTime'>
    readonly teams: FieldRef<"PatternUsage", 'String[]'>
    readonly createdAt: FieldRef<"PatternUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"PatternUsage", 'DateTime'>
    readonly patternId: FieldRef<"PatternUsage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PatternUsage findUnique
   */
  export type PatternUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * Filter, which PatternUsage to fetch.
     */
    where: PatternUsageWhereUniqueInput
  }

  /**
   * PatternUsage findUniqueOrThrow
   */
  export type PatternUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * Filter, which PatternUsage to fetch.
     */
    where: PatternUsageWhereUniqueInput
  }

  /**
   * PatternUsage findFirst
   */
  export type PatternUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * Filter, which PatternUsage to fetch.
     */
    where?: PatternUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternUsages to fetch.
     */
    orderBy?: PatternUsageOrderByWithRelationInput | PatternUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatternUsages.
     */
    cursor?: PatternUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatternUsages.
     */
    distinct?: PatternUsageScalarFieldEnum | PatternUsageScalarFieldEnum[]
  }

  /**
   * PatternUsage findFirstOrThrow
   */
  export type PatternUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * Filter, which PatternUsage to fetch.
     */
    where?: PatternUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternUsages to fetch.
     */
    orderBy?: PatternUsageOrderByWithRelationInput | PatternUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatternUsages.
     */
    cursor?: PatternUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatternUsages.
     */
    distinct?: PatternUsageScalarFieldEnum | PatternUsageScalarFieldEnum[]
  }

  /**
   * PatternUsage findMany
   */
  export type PatternUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * Filter, which PatternUsages to fetch.
     */
    where?: PatternUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatternUsages to fetch.
     */
    orderBy?: PatternUsageOrderByWithRelationInput | PatternUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatternUsages.
     */
    cursor?: PatternUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatternUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatternUsages.
     */
    skip?: number
    distinct?: PatternUsageScalarFieldEnum | PatternUsageScalarFieldEnum[]
  }

  /**
   * PatternUsage create
   */
  export type PatternUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a PatternUsage.
     */
    data: XOR<PatternUsageCreateInput, PatternUsageUncheckedCreateInput>
  }

  /**
   * PatternUsage createMany
   */
  export type PatternUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatternUsages.
     */
    data: PatternUsageCreateManyInput | PatternUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatternUsage createManyAndReturn
   */
  export type PatternUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatternUsages.
     */
    data: PatternUsageCreateManyInput | PatternUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternUsage update
   */
  export type PatternUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a PatternUsage.
     */
    data: XOR<PatternUsageUpdateInput, PatternUsageUncheckedUpdateInput>
    /**
     * Choose, which PatternUsage to update.
     */
    where: PatternUsageWhereUniqueInput
  }

  /**
   * PatternUsage updateMany
   */
  export type PatternUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatternUsages.
     */
    data: XOR<PatternUsageUpdateManyMutationInput, PatternUsageUncheckedUpdateManyInput>
    /**
     * Filter which PatternUsages to update
     */
    where?: PatternUsageWhereInput
  }

  /**
   * PatternUsage upsert
   */
  export type PatternUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the PatternUsage to update in case it exists.
     */
    where: PatternUsageWhereUniqueInput
    /**
     * In case the PatternUsage found by the `where` argument doesn't exist, create a new PatternUsage with this data.
     */
    create: XOR<PatternUsageCreateInput, PatternUsageUncheckedCreateInput>
    /**
     * In case the PatternUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternUsageUpdateInput, PatternUsageUncheckedUpdateInput>
  }

  /**
   * PatternUsage delete
   */
  export type PatternUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
    /**
     * Filter which PatternUsage to delete.
     */
    where: PatternUsageWhereUniqueInput
  }

  /**
   * PatternUsage deleteMany
   */
  export type PatternUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternUsages to delete
     */
    where?: PatternUsageWhereInput
  }

  /**
   * PatternUsage without action
   */
  export type PatternUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternUsage
     */
    select?: PatternUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternUsageInclude<ExtArgs> | null
  }


  /**
   * Model TokenDependency
   */

  export type AggregateTokenDependency = {
    _count: TokenDependencyCountAggregateOutputType | null
    _avg: TokenDependencyAvgAggregateOutputType | null
    _sum: TokenDependencySumAggregateOutputType | null
    _min: TokenDependencyMinAggregateOutputType | null
    _max: TokenDependencyMaxAggregateOutputType | null
  }

  export type TokenDependencyAvgAggregateOutputType = {
    strength: number | null
  }

  export type TokenDependencySumAggregateOutputType = {
    strength: number | null
  }

  export type TokenDependencyMinAggregateOutputType = {
    id: string | null
    relationship: $Enums.DependencyType | null
    strength: number | null
    tokenId: string | null
    dependsOnId: string | null
  }

  export type TokenDependencyMaxAggregateOutputType = {
    id: string | null
    relationship: $Enums.DependencyType | null
    strength: number | null
    tokenId: string | null
    dependsOnId: string | null
  }

  export type TokenDependencyCountAggregateOutputType = {
    id: number
    relationship: number
    strength: number
    tokenId: number
    dependsOnId: number
    _all: number
  }


  export type TokenDependencyAvgAggregateInputType = {
    strength?: true
  }

  export type TokenDependencySumAggregateInputType = {
    strength?: true
  }

  export type TokenDependencyMinAggregateInputType = {
    id?: true
    relationship?: true
    strength?: true
    tokenId?: true
    dependsOnId?: true
  }

  export type TokenDependencyMaxAggregateInputType = {
    id?: true
    relationship?: true
    strength?: true
    tokenId?: true
    dependsOnId?: true
  }

  export type TokenDependencyCountAggregateInputType = {
    id?: true
    relationship?: true
    strength?: true
    tokenId?: true
    dependsOnId?: true
    _all?: true
  }

  export type TokenDependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenDependency to aggregate.
     */
    where?: TokenDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenDependencies to fetch.
     */
    orderBy?: TokenDependencyOrderByWithRelationInput | TokenDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenDependencies
    **/
    _count?: true | TokenDependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenDependencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenDependencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenDependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenDependencyMaxAggregateInputType
  }

  export type GetTokenDependencyAggregateType<T extends TokenDependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenDependency[P]>
      : GetScalarType<T[P], AggregateTokenDependency[P]>
  }




  export type TokenDependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenDependencyWhereInput
    orderBy?: TokenDependencyOrderByWithAggregationInput | TokenDependencyOrderByWithAggregationInput[]
    by: TokenDependencyScalarFieldEnum[] | TokenDependencyScalarFieldEnum
    having?: TokenDependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenDependencyCountAggregateInputType | true
    _avg?: TokenDependencyAvgAggregateInputType
    _sum?: TokenDependencySumAggregateInputType
    _min?: TokenDependencyMinAggregateInputType
    _max?: TokenDependencyMaxAggregateInputType
  }

  export type TokenDependencyGroupByOutputType = {
    id: string
    relationship: $Enums.DependencyType
    strength: number
    tokenId: string
    dependsOnId: string
    _count: TokenDependencyCountAggregateOutputType | null
    _avg: TokenDependencyAvgAggregateOutputType | null
    _sum: TokenDependencySumAggregateOutputType | null
    _min: TokenDependencyMinAggregateOutputType | null
    _max: TokenDependencyMaxAggregateOutputType | null
  }

  type GetTokenDependencyGroupByPayload<T extends TokenDependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenDependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenDependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenDependencyGroupByOutputType[P]>
            : GetScalarType<T[P], TokenDependencyGroupByOutputType[P]>
        }
      >
    >


  export type TokenDependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationship?: boolean
    strength?: boolean
    tokenId?: boolean
    dependsOnId?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    dependsOn?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenDependency"]>

  export type TokenDependencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationship?: boolean
    strength?: boolean
    tokenId?: boolean
    dependsOnId?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    dependsOn?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenDependency"]>

  export type TokenDependencySelectScalar = {
    id?: boolean
    relationship?: boolean
    strength?: boolean
    tokenId?: boolean
    dependsOnId?: boolean
  }

  export type TokenDependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    dependsOn?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type TokenDependencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    dependsOn?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $TokenDependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenDependency"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
      dependsOn: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationship: $Enums.DependencyType
      strength: number
      tokenId: string
      dependsOnId: string
    }, ExtArgs["result"]["tokenDependency"]>
    composites: {}
  }

  type TokenDependencyGetPayload<S extends boolean | null | undefined | TokenDependencyDefaultArgs> = $Result.GetResult<Prisma.$TokenDependencyPayload, S>

  type TokenDependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenDependencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenDependencyCountAggregateInputType | true
    }

  export interface TokenDependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenDependency'], meta: { name: 'TokenDependency' } }
    /**
     * Find zero or one TokenDependency that matches the filter.
     * @param {TokenDependencyFindUniqueArgs} args - Arguments to find a TokenDependency
     * @example
     * // Get one TokenDependency
     * const tokenDependency = await prisma.tokenDependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenDependencyFindUniqueArgs>(args: SelectSubset<T, TokenDependencyFindUniqueArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenDependency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenDependencyFindUniqueOrThrowArgs} args - Arguments to find a TokenDependency
     * @example
     * // Get one TokenDependency
     * const tokenDependency = await prisma.tokenDependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenDependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenDependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenDependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyFindFirstArgs} args - Arguments to find a TokenDependency
     * @example
     * // Get one TokenDependency
     * const tokenDependency = await prisma.tokenDependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenDependencyFindFirstArgs>(args?: SelectSubset<T, TokenDependencyFindFirstArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenDependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyFindFirstOrThrowArgs} args - Arguments to find a TokenDependency
     * @example
     * // Get one TokenDependency
     * const tokenDependency = await prisma.tokenDependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenDependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenDependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenDependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenDependencies
     * const tokenDependencies = await prisma.tokenDependency.findMany()
     * 
     * // Get first 10 TokenDependencies
     * const tokenDependencies = await prisma.tokenDependency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenDependencyWithIdOnly = await prisma.tokenDependency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenDependencyFindManyArgs>(args?: SelectSubset<T, TokenDependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenDependency.
     * @param {TokenDependencyCreateArgs} args - Arguments to create a TokenDependency.
     * @example
     * // Create one TokenDependency
     * const TokenDependency = await prisma.tokenDependency.create({
     *   data: {
     *     // ... data to create a TokenDependency
     *   }
     * })
     * 
     */
    create<T extends TokenDependencyCreateArgs>(args: SelectSubset<T, TokenDependencyCreateArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenDependencies.
     * @param {TokenDependencyCreateManyArgs} args - Arguments to create many TokenDependencies.
     * @example
     * // Create many TokenDependencies
     * const tokenDependency = await prisma.tokenDependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenDependencyCreateManyArgs>(args?: SelectSubset<T, TokenDependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenDependencies and returns the data saved in the database.
     * @param {TokenDependencyCreateManyAndReturnArgs} args - Arguments to create many TokenDependencies.
     * @example
     * // Create many TokenDependencies
     * const tokenDependency = await prisma.tokenDependency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenDependencies and only return the `id`
     * const tokenDependencyWithIdOnly = await prisma.tokenDependency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenDependencyCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenDependencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenDependency.
     * @param {TokenDependencyDeleteArgs} args - Arguments to delete one TokenDependency.
     * @example
     * // Delete one TokenDependency
     * const TokenDependency = await prisma.tokenDependency.delete({
     *   where: {
     *     // ... filter to delete one TokenDependency
     *   }
     * })
     * 
     */
    delete<T extends TokenDependencyDeleteArgs>(args: SelectSubset<T, TokenDependencyDeleteArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenDependency.
     * @param {TokenDependencyUpdateArgs} args - Arguments to update one TokenDependency.
     * @example
     * // Update one TokenDependency
     * const tokenDependency = await prisma.tokenDependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenDependencyUpdateArgs>(args: SelectSubset<T, TokenDependencyUpdateArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenDependencies.
     * @param {TokenDependencyDeleteManyArgs} args - Arguments to filter TokenDependencies to delete.
     * @example
     * // Delete a few TokenDependencies
     * const { count } = await prisma.tokenDependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDependencyDeleteManyArgs>(args?: SelectSubset<T, TokenDependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenDependencies
     * const tokenDependency = await prisma.tokenDependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenDependencyUpdateManyArgs>(args: SelectSubset<T, TokenDependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenDependency.
     * @param {TokenDependencyUpsertArgs} args - Arguments to update or create a TokenDependency.
     * @example
     * // Update or create a TokenDependency
     * const tokenDependency = await prisma.tokenDependency.upsert({
     *   create: {
     *     // ... data to create a TokenDependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenDependency we want to update
     *   }
     * })
     */
    upsert<T extends TokenDependencyUpsertArgs>(args: SelectSubset<T, TokenDependencyUpsertArgs<ExtArgs>>): Prisma__TokenDependencyClient<$Result.GetResult<Prisma.$TokenDependencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyCountArgs} args - Arguments to filter TokenDependencies to count.
     * @example
     * // Count the number of TokenDependencies
     * const count = await prisma.tokenDependency.count({
     *   where: {
     *     // ... the filter for the TokenDependencies we want to count
     *   }
     * })
    **/
    count<T extends TokenDependencyCountArgs>(
      args?: Subset<T, TokenDependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenDependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenDependencyAggregateArgs>(args: Subset<T, TokenDependencyAggregateArgs>): Prisma.PrismaPromise<GetTokenDependencyAggregateType<T>>

    /**
     * Group by TokenDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenDependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenDependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenDependencyGroupByArgs['orderBy'] }
        : { orderBy?: TokenDependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenDependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenDependency model
   */
  readonly fields: TokenDependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenDependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenDependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dependsOn<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenDependency model
   */ 
  interface TokenDependencyFieldRefs {
    readonly id: FieldRef<"TokenDependency", 'String'>
    readonly relationship: FieldRef<"TokenDependency", 'DependencyType'>
    readonly strength: FieldRef<"TokenDependency", 'Int'>
    readonly tokenId: FieldRef<"TokenDependency", 'String'>
    readonly dependsOnId: FieldRef<"TokenDependency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TokenDependency findUnique
   */
  export type TokenDependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TokenDependency to fetch.
     */
    where: TokenDependencyWhereUniqueInput
  }

  /**
   * TokenDependency findUniqueOrThrow
   */
  export type TokenDependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TokenDependency to fetch.
     */
    where: TokenDependencyWhereUniqueInput
  }

  /**
   * TokenDependency findFirst
   */
  export type TokenDependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TokenDependency to fetch.
     */
    where?: TokenDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenDependencies to fetch.
     */
    orderBy?: TokenDependencyOrderByWithRelationInput | TokenDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenDependencies.
     */
    cursor?: TokenDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenDependencies.
     */
    distinct?: TokenDependencyScalarFieldEnum | TokenDependencyScalarFieldEnum[]
  }

  /**
   * TokenDependency findFirstOrThrow
   */
  export type TokenDependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TokenDependency to fetch.
     */
    where?: TokenDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenDependencies to fetch.
     */
    orderBy?: TokenDependencyOrderByWithRelationInput | TokenDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenDependencies.
     */
    cursor?: TokenDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenDependencies.
     */
    distinct?: TokenDependencyScalarFieldEnum | TokenDependencyScalarFieldEnum[]
  }

  /**
   * TokenDependency findMany
   */
  export type TokenDependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TokenDependencies to fetch.
     */
    where?: TokenDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenDependencies to fetch.
     */
    orderBy?: TokenDependencyOrderByWithRelationInput | TokenDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenDependencies.
     */
    cursor?: TokenDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenDependencies.
     */
    skip?: number
    distinct?: TokenDependencyScalarFieldEnum | TokenDependencyScalarFieldEnum[]
  }

  /**
   * TokenDependency create
   */
  export type TokenDependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenDependency.
     */
    data: XOR<TokenDependencyCreateInput, TokenDependencyUncheckedCreateInput>
  }

  /**
   * TokenDependency createMany
   */
  export type TokenDependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenDependencies.
     */
    data: TokenDependencyCreateManyInput | TokenDependencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenDependency createManyAndReturn
   */
  export type TokenDependencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenDependencies.
     */
    data: TokenDependencyCreateManyInput | TokenDependencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenDependency update
   */
  export type TokenDependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenDependency.
     */
    data: XOR<TokenDependencyUpdateInput, TokenDependencyUncheckedUpdateInput>
    /**
     * Choose, which TokenDependency to update.
     */
    where: TokenDependencyWhereUniqueInput
  }

  /**
   * TokenDependency updateMany
   */
  export type TokenDependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenDependencies.
     */
    data: XOR<TokenDependencyUpdateManyMutationInput, TokenDependencyUncheckedUpdateManyInput>
    /**
     * Filter which TokenDependencies to update
     */
    where?: TokenDependencyWhereInput
  }

  /**
   * TokenDependency upsert
   */
  export type TokenDependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenDependency to update in case it exists.
     */
    where: TokenDependencyWhereUniqueInput
    /**
     * In case the TokenDependency found by the `where` argument doesn't exist, create a new TokenDependency with this data.
     */
    create: XOR<TokenDependencyCreateInput, TokenDependencyUncheckedCreateInput>
    /**
     * In case the TokenDependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenDependencyUpdateInput, TokenDependencyUncheckedUpdateInput>
  }

  /**
   * TokenDependency delete
   */
  export type TokenDependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
    /**
     * Filter which TokenDependency to delete.
     */
    where: TokenDependencyWhereUniqueInput
  }

  /**
   * TokenDependency deleteMany
   */
  export type TokenDependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenDependencies to delete
     */
    where?: TokenDependencyWhereInput
  }

  /**
   * TokenDependency without action
   */
  export type TokenDependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenDependency
     */
    select?: TokenDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenDependencyInclude<ExtArgs> | null
  }


  /**
   * Model ChangeRequest
   */

  export type AggregateChangeRequest = {
    _count: ChangeRequestCountAggregateOutputType | null
    _min: ChangeRequestMinAggregateOutputType | null
    _max: ChangeRequestMaxAggregateOutputType | null
  }

  export type ChangeRequestMinAggregateOutputType = {
    id: string | null
    type: $Enums.ChangeType | null
    reason: string | null
    status: $Enums.RequestStatus | null
    testDeploymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tokenId: string | null
    requestedById: string | null
    approvedById: string | null
  }

  export type ChangeRequestMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ChangeType | null
    reason: string | null
    status: $Enums.RequestStatus | null
    testDeploymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tokenId: string | null
    requestedById: string | null
    approvedById: string | null
  }

  export type ChangeRequestCountAggregateOutputType = {
    id: number
    type: number
    proposedChanges: number
    reason: number
    impact: number
    status: number
    testDeploymentId: number
    createdAt: number
    updatedAt: number
    tokenId: number
    requestedById: number
    approvedById: number
    _all: number
  }


  export type ChangeRequestMinAggregateInputType = {
    id?: true
    type?: true
    reason?: true
    status?: true
    testDeploymentId?: true
    createdAt?: true
    updatedAt?: true
    tokenId?: true
    requestedById?: true
    approvedById?: true
  }

  export type ChangeRequestMaxAggregateInputType = {
    id?: true
    type?: true
    reason?: true
    status?: true
    testDeploymentId?: true
    createdAt?: true
    updatedAt?: true
    tokenId?: true
    requestedById?: true
    approvedById?: true
  }

  export type ChangeRequestCountAggregateInputType = {
    id?: true
    type?: true
    proposedChanges?: true
    reason?: true
    impact?: true
    status?: true
    testDeploymentId?: true
    createdAt?: true
    updatedAt?: true
    tokenId?: true
    requestedById?: true
    approvedById?: true
    _all?: true
  }

  export type ChangeRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeRequest to aggregate.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeRequests
    **/
    _count?: true | ChangeRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeRequestMaxAggregateInputType
  }

  export type GetChangeRequestAggregateType<T extends ChangeRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeRequest[P]>
      : GetScalarType<T[P], AggregateChangeRequest[P]>
  }




  export type ChangeRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithAggregationInput | ChangeRequestOrderByWithAggregationInput[]
    by: ChangeRequestScalarFieldEnum[] | ChangeRequestScalarFieldEnum
    having?: ChangeRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeRequestCountAggregateInputType | true
    _min?: ChangeRequestMinAggregateInputType
    _max?: ChangeRequestMaxAggregateInputType
  }

  export type ChangeRequestGroupByOutputType = {
    id: string
    type: $Enums.ChangeType
    proposedChanges: JsonValue
    reason: string
    impact: JsonValue
    status: $Enums.RequestStatus
    testDeploymentId: string | null
    createdAt: Date
    updatedAt: Date
    tokenId: string
    requestedById: string
    approvedById: string | null
    _count: ChangeRequestCountAggregateOutputType | null
    _min: ChangeRequestMinAggregateOutputType | null
    _max: ChangeRequestMaxAggregateOutputType | null
  }

  type GetChangeRequestGroupByPayload<T extends ChangeRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeRequestGroupByOutputType[P]>
        }
      >
    >


  export type ChangeRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    proposedChanges?: boolean
    reason?: boolean
    impact?: boolean
    status?: boolean
    testDeploymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokenId?: boolean
    requestedById?: boolean
    approvedById?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ChangeRequest$approvedByArgs<ExtArgs>
    notifications?: boolean | ChangeRequest$notificationsArgs<ExtArgs>
    _count?: boolean | ChangeRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    proposedChanges?: boolean
    reason?: boolean
    impact?: boolean
    status?: boolean
    testDeploymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokenId?: boolean
    requestedById?: boolean
    approvedById?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ChangeRequest$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectScalar = {
    id?: boolean
    type?: boolean
    proposedChanges?: boolean
    reason?: boolean
    impact?: boolean
    status?: boolean
    testDeploymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokenId?: boolean
    requestedById?: boolean
    approvedById?: boolean
  }

  export type ChangeRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ChangeRequest$approvedByArgs<ExtArgs>
    notifications?: boolean | ChangeRequest$notificationsArgs<ExtArgs>
    _count?: boolean | ChangeRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChangeRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | ChangeRequest$approvedByArgs<ExtArgs>
  }

  export type $ChangeRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeRequest"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ChangeType
      proposedChanges: Prisma.JsonValue
      reason: string
      impact: Prisma.JsonValue
      status: $Enums.RequestStatus
      testDeploymentId: string | null
      createdAt: Date
      updatedAt: Date
      tokenId: string
      requestedById: string
      approvedById: string | null
    }, ExtArgs["result"]["changeRequest"]>
    composites: {}
  }

  type ChangeRequestGetPayload<S extends boolean | null | undefined | ChangeRequestDefaultArgs> = $Result.GetResult<Prisma.$ChangeRequestPayload, S>

  type ChangeRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChangeRequestCountAggregateInputType | true
    }

  export interface ChangeRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeRequest'], meta: { name: 'ChangeRequest' } }
    /**
     * Find zero or one ChangeRequest that matches the filter.
     * @param {ChangeRequestFindUniqueArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeRequestFindUniqueArgs>(args: SelectSubset<T, ChangeRequestFindUniqueArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChangeRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChangeRequestFindUniqueOrThrowArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChangeRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindFirstArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeRequestFindFirstArgs>(args?: SelectSubset<T, ChangeRequestFindFirstArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChangeRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindFirstOrThrowArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChangeRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeRequests
     * const changeRequests = await prisma.changeRequest.findMany()
     * 
     * // Get first 10 ChangeRequests
     * const changeRequests = await prisma.changeRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeRequestFindManyArgs>(args?: SelectSubset<T, ChangeRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChangeRequest.
     * @param {ChangeRequestCreateArgs} args - Arguments to create a ChangeRequest.
     * @example
     * // Create one ChangeRequest
     * const ChangeRequest = await prisma.changeRequest.create({
     *   data: {
     *     // ... data to create a ChangeRequest
     *   }
     * })
     * 
     */
    create<T extends ChangeRequestCreateArgs>(args: SelectSubset<T, ChangeRequestCreateArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChangeRequests.
     * @param {ChangeRequestCreateManyArgs} args - Arguments to create many ChangeRequests.
     * @example
     * // Create many ChangeRequests
     * const changeRequest = await prisma.changeRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeRequestCreateManyArgs>(args?: SelectSubset<T, ChangeRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeRequests and returns the data saved in the database.
     * @param {ChangeRequestCreateManyAndReturnArgs} args - Arguments to create many ChangeRequests.
     * @example
     * // Create many ChangeRequests
     * const changeRequest = await prisma.changeRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeRequests and only return the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChangeRequest.
     * @param {ChangeRequestDeleteArgs} args - Arguments to delete one ChangeRequest.
     * @example
     * // Delete one ChangeRequest
     * const ChangeRequest = await prisma.changeRequest.delete({
     *   where: {
     *     // ... filter to delete one ChangeRequest
     *   }
     * })
     * 
     */
    delete<T extends ChangeRequestDeleteArgs>(args: SelectSubset<T, ChangeRequestDeleteArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChangeRequest.
     * @param {ChangeRequestUpdateArgs} args - Arguments to update one ChangeRequest.
     * @example
     * // Update one ChangeRequest
     * const changeRequest = await prisma.changeRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeRequestUpdateArgs>(args: SelectSubset<T, ChangeRequestUpdateArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChangeRequests.
     * @param {ChangeRequestDeleteManyArgs} args - Arguments to filter ChangeRequests to delete.
     * @example
     * // Delete a few ChangeRequests
     * const { count } = await prisma.changeRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeRequestDeleteManyArgs>(args?: SelectSubset<T, ChangeRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeRequests
     * const changeRequest = await prisma.changeRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeRequestUpdateManyArgs>(args: SelectSubset<T, ChangeRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangeRequest.
     * @param {ChangeRequestUpsertArgs} args - Arguments to update or create a ChangeRequest.
     * @example
     * // Update or create a ChangeRequest
     * const changeRequest = await prisma.changeRequest.upsert({
     *   create: {
     *     // ... data to create a ChangeRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeRequest we want to update
     *   }
     * })
     */
    upsert<T extends ChangeRequestUpsertArgs>(args: SelectSubset<T, ChangeRequestUpsertArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestCountArgs} args - Arguments to filter ChangeRequests to count.
     * @example
     * // Count the number of ChangeRequests
     * const count = await prisma.changeRequest.count({
     *   where: {
     *     // ... the filter for the ChangeRequests we want to count
     *   }
     * })
    **/
    count<T extends ChangeRequestCountArgs>(
      args?: Subset<T, ChangeRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeRequestAggregateArgs>(args: Subset<T, ChangeRequestAggregateArgs>): Prisma.PrismaPromise<GetChangeRequestAggregateType<T>>

    /**
     * Group by ChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeRequestGroupByArgs['orderBy'] }
        : { orderBy?: ChangeRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeRequest model
   */
  readonly fields: ChangeRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends ChangeRequest$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, ChangeRequest$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends ChangeRequest$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, ChangeRequest$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeRequest model
   */ 
  interface ChangeRequestFieldRefs {
    readonly id: FieldRef<"ChangeRequest", 'String'>
    readonly type: FieldRef<"ChangeRequest", 'ChangeType'>
    readonly proposedChanges: FieldRef<"ChangeRequest", 'Json'>
    readonly reason: FieldRef<"ChangeRequest", 'String'>
    readonly impact: FieldRef<"ChangeRequest", 'Json'>
    readonly status: FieldRef<"ChangeRequest", 'RequestStatus'>
    readonly testDeploymentId: FieldRef<"ChangeRequest", 'String'>
    readonly createdAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly tokenId: FieldRef<"ChangeRequest", 'String'>
    readonly requestedById: FieldRef<"ChangeRequest", 'String'>
    readonly approvedById: FieldRef<"ChangeRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChangeRequest findUnique
   */
  export type ChangeRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest findUniqueOrThrow
   */
  export type ChangeRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest findFirst
   */
  export type ChangeRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeRequests.
     */
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest findFirstOrThrow
   */
  export type ChangeRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeRequests.
     */
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest findMany
   */
  export type ChangeRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequests to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest create
   */
  export type ChangeRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeRequest.
     */
    data: XOR<ChangeRequestCreateInput, ChangeRequestUncheckedCreateInput>
  }

  /**
   * ChangeRequest createMany
   */
  export type ChangeRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeRequests.
     */
    data: ChangeRequestCreateManyInput | ChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeRequest createManyAndReturn
   */
  export type ChangeRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChangeRequests.
     */
    data: ChangeRequestCreateManyInput | ChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeRequest update
   */
  export type ChangeRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeRequest.
     */
    data: XOR<ChangeRequestUpdateInput, ChangeRequestUncheckedUpdateInput>
    /**
     * Choose, which ChangeRequest to update.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest updateMany
   */
  export type ChangeRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeRequests.
     */
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChangeRequests to update
     */
    where?: ChangeRequestWhereInput
  }

  /**
   * ChangeRequest upsert
   */
  export type ChangeRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeRequest to update in case it exists.
     */
    where: ChangeRequestWhereUniqueInput
    /**
     * In case the ChangeRequest found by the `where` argument doesn't exist, create a new ChangeRequest with this data.
     */
    create: XOR<ChangeRequestCreateInput, ChangeRequestUncheckedCreateInput>
    /**
     * In case the ChangeRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeRequestUpdateInput, ChangeRequestUncheckedUpdateInput>
  }

  /**
   * ChangeRequest delete
   */
  export type ChangeRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter which ChangeRequest to delete.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest deleteMany
   */
  export type ChangeRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeRequests to delete
     */
    where?: ChangeRequestWhereInput
  }

  /**
   * ChangeRequest.approvedBy
   */
  export type ChangeRequest$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChangeRequest.notifications
   */
  export type ChangeRequest$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * ChangeRequest without action
   */
  export type ChangeRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    priority: $Enums.Priority | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
    userId: string | null
    changeRequestId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    priority: $Enums.Priority | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
    userId: string | null
    changeRequestId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    priority: number
    isRead: number
    channels: number
    metadata: number
    createdAt: number
    readAt: number
    userId: number
    changeRequestId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    createdAt?: true
    readAt?: true
    userId?: true
    changeRequestId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    createdAt?: true
    readAt?: true
    userId?: true
    changeRequestId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    isRead?: true
    channels?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    userId?: true
    changeRequestId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority: $Enums.Priority
    isRead: boolean
    channels: string[]
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    userId: string
    changeRequestId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    channels?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
    changeRequestId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    changeRequest?: boolean | Notification$changeRequestArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    channels?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
    changeRequestId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    changeRequest?: boolean | Notification$changeRequestArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    isRead?: boolean
    channels?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
    changeRequestId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    changeRequest?: boolean | Notification$changeRequestArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    changeRequest?: boolean | Notification$changeRequestArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      changeRequest: Prisma.$ChangeRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: $Enums.NotificationType
      priority: $Enums.Priority
      isRead: boolean
      channels: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
      userId: string
      changeRequestId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changeRequest<T extends Notification$changeRequestArgs<ExtArgs> = {}>(args?: Subset<T, Notification$changeRequestArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly priority: FieldRef<"Notification", 'Priority'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly channels: FieldRef<"Notification", 'String[]'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly changeRequestId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.changeRequest
   */
  export type Notification$changeRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ScanResult
   */

  export type AggregateScanResult = {
    _count: ScanResultCountAggregateOutputType | null
    _avg: ScanResultAvgAggregateOutputType | null
    _sum: ScanResultSumAggregateOutputType | null
    _min: ScanResultMinAggregateOutputType | null
    _max: ScanResultMaxAggregateOutputType | null
  }

  export type ScanResultAvgAggregateOutputType = {
    tokensFound: number | null
    coverage: number | null
  }

  export type ScanResultSumAggregateOutputType = {
    tokensFound: number | null
    coverage: number | null
  }

  export type ScanResultMinAggregateOutputType = {
    id: string | null
    scanDate: Date | null
    tokensFound: number | null
    coverage: number | null
    applicationId: string | null
  }

  export type ScanResultMaxAggregateOutputType = {
    id: string | null
    scanDate: Date | null
    tokensFound: number | null
    coverage: number | null
    applicationId: string | null
  }

  export type ScanResultCountAggregateOutputType = {
    id: number
    scanDate: number
    tokensFound: number
    coverage: number
    results: number
    errors: number
    applicationId: number
    _all: number
  }


  export type ScanResultAvgAggregateInputType = {
    tokensFound?: true
    coverage?: true
  }

  export type ScanResultSumAggregateInputType = {
    tokensFound?: true
    coverage?: true
  }

  export type ScanResultMinAggregateInputType = {
    id?: true
    scanDate?: true
    tokensFound?: true
    coverage?: true
    applicationId?: true
  }

  export type ScanResultMaxAggregateInputType = {
    id?: true
    scanDate?: true
    tokensFound?: true
    coverage?: true
    applicationId?: true
  }

  export type ScanResultCountAggregateInputType = {
    id?: true
    scanDate?: true
    tokensFound?: true
    coverage?: true
    results?: true
    errors?: true
    applicationId?: true
    _all?: true
  }

  export type ScanResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScanResult to aggregate.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScanResults
    **/
    _count?: true | ScanResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScanResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScanResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScanResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScanResultMaxAggregateInputType
  }

  export type GetScanResultAggregateType<T extends ScanResultAggregateArgs> = {
        [P in keyof T & keyof AggregateScanResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScanResult[P]>
      : GetScalarType<T[P], AggregateScanResult[P]>
  }




  export type ScanResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScanResultWhereInput
    orderBy?: ScanResultOrderByWithAggregationInput | ScanResultOrderByWithAggregationInput[]
    by: ScanResultScalarFieldEnum[] | ScanResultScalarFieldEnum
    having?: ScanResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScanResultCountAggregateInputType | true
    _avg?: ScanResultAvgAggregateInputType
    _sum?: ScanResultSumAggregateInputType
    _min?: ScanResultMinAggregateInputType
    _max?: ScanResultMaxAggregateInputType
  }

  export type ScanResultGroupByOutputType = {
    id: string
    scanDate: Date
    tokensFound: number
    coverage: number
    results: JsonValue
    errors: string[]
    applicationId: string
    _count: ScanResultCountAggregateOutputType | null
    _avg: ScanResultAvgAggregateOutputType | null
    _sum: ScanResultSumAggregateOutputType | null
    _min: ScanResultMinAggregateOutputType | null
    _max: ScanResultMaxAggregateOutputType | null
  }

  type GetScanResultGroupByPayload<T extends ScanResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScanResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScanResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScanResultGroupByOutputType[P]>
            : GetScalarType<T[P], ScanResultGroupByOutputType[P]>
        }
      >
    >


  export type ScanResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scanDate?: boolean
    tokensFound?: boolean
    coverage?: boolean
    results?: boolean
    errors?: boolean
    applicationId?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scanResult"]>

  export type ScanResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scanDate?: boolean
    tokensFound?: boolean
    coverage?: boolean
    results?: boolean
    errors?: boolean
    applicationId?: boolean
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scanResult"]>

  export type ScanResultSelectScalar = {
    id?: boolean
    scanDate?: boolean
    tokensFound?: boolean
    coverage?: boolean
    results?: boolean
    errors?: boolean
    applicationId?: boolean
  }

  export type ScanResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type ScanResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $ScanResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScanResult"
    objects: {
      application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scanDate: Date
      tokensFound: number
      coverage: number
      results: Prisma.JsonValue
      errors: string[]
      applicationId: string
    }, ExtArgs["result"]["scanResult"]>
    composites: {}
  }

  type ScanResultGetPayload<S extends boolean | null | undefined | ScanResultDefaultArgs> = $Result.GetResult<Prisma.$ScanResultPayload, S>

  type ScanResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScanResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScanResultCountAggregateInputType | true
    }

  export interface ScanResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScanResult'], meta: { name: 'ScanResult' } }
    /**
     * Find zero or one ScanResult that matches the filter.
     * @param {ScanResultFindUniqueArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScanResultFindUniqueArgs>(args: SelectSubset<T, ScanResultFindUniqueArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScanResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScanResultFindUniqueOrThrowArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScanResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ScanResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScanResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultFindFirstArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScanResultFindFirstArgs>(args?: SelectSubset<T, ScanResultFindFirstArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScanResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultFindFirstOrThrowArgs} args - Arguments to find a ScanResult
     * @example
     * // Get one ScanResult
     * const scanResult = await prisma.scanResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScanResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ScanResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScanResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScanResults
     * const scanResults = await prisma.scanResult.findMany()
     * 
     * // Get first 10 ScanResults
     * const scanResults = await prisma.scanResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scanResultWithIdOnly = await prisma.scanResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScanResultFindManyArgs>(args?: SelectSubset<T, ScanResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScanResult.
     * @param {ScanResultCreateArgs} args - Arguments to create a ScanResult.
     * @example
     * // Create one ScanResult
     * const ScanResult = await prisma.scanResult.create({
     *   data: {
     *     // ... data to create a ScanResult
     *   }
     * })
     * 
     */
    create<T extends ScanResultCreateArgs>(args: SelectSubset<T, ScanResultCreateArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScanResults.
     * @param {ScanResultCreateManyArgs} args - Arguments to create many ScanResults.
     * @example
     * // Create many ScanResults
     * const scanResult = await prisma.scanResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScanResultCreateManyArgs>(args?: SelectSubset<T, ScanResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScanResults and returns the data saved in the database.
     * @param {ScanResultCreateManyAndReturnArgs} args - Arguments to create many ScanResults.
     * @example
     * // Create many ScanResults
     * const scanResult = await prisma.scanResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScanResults and only return the `id`
     * const scanResultWithIdOnly = await prisma.scanResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScanResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ScanResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScanResult.
     * @param {ScanResultDeleteArgs} args - Arguments to delete one ScanResult.
     * @example
     * // Delete one ScanResult
     * const ScanResult = await prisma.scanResult.delete({
     *   where: {
     *     // ... filter to delete one ScanResult
     *   }
     * })
     * 
     */
    delete<T extends ScanResultDeleteArgs>(args: SelectSubset<T, ScanResultDeleteArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScanResult.
     * @param {ScanResultUpdateArgs} args - Arguments to update one ScanResult.
     * @example
     * // Update one ScanResult
     * const scanResult = await prisma.scanResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScanResultUpdateArgs>(args: SelectSubset<T, ScanResultUpdateArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScanResults.
     * @param {ScanResultDeleteManyArgs} args - Arguments to filter ScanResults to delete.
     * @example
     * // Delete a few ScanResults
     * const { count } = await prisma.scanResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScanResultDeleteManyArgs>(args?: SelectSubset<T, ScanResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScanResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScanResults
     * const scanResult = await prisma.scanResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScanResultUpdateManyArgs>(args: SelectSubset<T, ScanResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScanResult.
     * @param {ScanResultUpsertArgs} args - Arguments to update or create a ScanResult.
     * @example
     * // Update or create a ScanResult
     * const scanResult = await prisma.scanResult.upsert({
     *   create: {
     *     // ... data to create a ScanResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScanResult we want to update
     *   }
     * })
     */
    upsert<T extends ScanResultUpsertArgs>(args: SelectSubset<T, ScanResultUpsertArgs<ExtArgs>>): Prisma__ScanResultClient<$Result.GetResult<Prisma.$ScanResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScanResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultCountArgs} args - Arguments to filter ScanResults to count.
     * @example
     * // Count the number of ScanResults
     * const count = await prisma.scanResult.count({
     *   where: {
     *     // ... the filter for the ScanResults we want to count
     *   }
     * })
    **/
    count<T extends ScanResultCountArgs>(
      args?: Subset<T, ScanResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScanResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScanResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScanResultAggregateArgs>(args: Subset<T, ScanResultAggregateArgs>): Prisma.PrismaPromise<GetScanResultAggregateType<T>>

    /**
     * Group by ScanResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScanResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScanResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScanResultGroupByArgs['orderBy'] }
        : { orderBy?: ScanResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScanResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScanResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScanResult model
   */
  readonly fields: ScanResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScanResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScanResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScanResult model
   */ 
  interface ScanResultFieldRefs {
    readonly id: FieldRef<"ScanResult", 'String'>
    readonly scanDate: FieldRef<"ScanResult", 'DateTime'>
    readonly tokensFound: FieldRef<"ScanResult", 'Int'>
    readonly coverage: FieldRef<"ScanResult", 'Float'>
    readonly results: FieldRef<"ScanResult", 'Json'>
    readonly errors: FieldRef<"ScanResult", 'String[]'>
    readonly applicationId: FieldRef<"ScanResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScanResult findUnique
   */
  export type ScanResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult findUniqueOrThrow
   */
  export type ScanResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult findFirst
   */
  export type ScanResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScanResults.
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScanResults.
     */
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * ScanResult findFirstOrThrow
   */
  export type ScanResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * Filter, which ScanResult to fetch.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScanResults.
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScanResults.
     */
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * ScanResult findMany
   */
  export type ScanResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * Filter, which ScanResults to fetch.
     */
    where?: ScanResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScanResults to fetch.
     */
    orderBy?: ScanResultOrderByWithRelationInput | ScanResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScanResults.
     */
    cursor?: ScanResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScanResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScanResults.
     */
    skip?: number
    distinct?: ScanResultScalarFieldEnum | ScanResultScalarFieldEnum[]
  }

  /**
   * ScanResult create
   */
  export type ScanResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ScanResult.
     */
    data: XOR<ScanResultCreateInput, ScanResultUncheckedCreateInput>
  }

  /**
   * ScanResult createMany
   */
  export type ScanResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScanResults.
     */
    data: ScanResultCreateManyInput | ScanResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScanResult createManyAndReturn
   */
  export type ScanResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScanResults.
     */
    data: ScanResultCreateManyInput | ScanResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScanResult update
   */
  export type ScanResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ScanResult.
     */
    data: XOR<ScanResultUpdateInput, ScanResultUncheckedUpdateInput>
    /**
     * Choose, which ScanResult to update.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult updateMany
   */
  export type ScanResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScanResults.
     */
    data: XOR<ScanResultUpdateManyMutationInput, ScanResultUncheckedUpdateManyInput>
    /**
     * Filter which ScanResults to update
     */
    where?: ScanResultWhereInput
  }

  /**
   * ScanResult upsert
   */
  export type ScanResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ScanResult to update in case it exists.
     */
    where: ScanResultWhereUniqueInput
    /**
     * In case the ScanResult found by the `where` argument doesn't exist, create a new ScanResult with this data.
     */
    create: XOR<ScanResultCreateInput, ScanResultUncheckedCreateInput>
    /**
     * In case the ScanResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScanResultUpdateInput, ScanResultUncheckedUpdateInput>
  }

  /**
   * ScanResult delete
   */
  export type ScanResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
    /**
     * Filter which ScanResult to delete.
     */
    where: ScanResultWhereUniqueInput
  }

  /**
   * ScanResult deleteMany
   */
  export type ScanResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScanResults to delete
     */
    where?: ScanResultWhereInput
  }

  /**
   * ScanResult without action
   */
  export type ScanResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScanResult
     */
    select?: ScanResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScanResultInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    team: 'team',
    role: 'role',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    tokenId: 'tokenId',
    name: 'name',
    currentVersion: 'currentVersion',
    value: 'value',
    category: 'category',
    criticality: 'criticality',
    reviewRequired: 'reviewRequired',
    deprecationStatus: 'deprecationStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const TokenHistoryScalarFieldEnum: {
    id: 'id',
    version: 'version',
    changes: 'changes',
    changedAt: 'changedAt',
    approvedAt: 'approvedAt',
    rollbackInfo: 'rollbackInfo',
    tokenId: 'tokenId',
    changedById: 'changedById'
  };

  export type TokenHistoryScalarFieldEnum = (typeof TokenHistoryScalarFieldEnum)[keyof typeof TokenHistoryScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactEmail: 'contactEmail',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    domain: 'domain',
    repository: 'repository',
    status: 'status',
    lastScanned: 'lastScanned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamId: 'teamId'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const TokenUsageScalarFieldEnum: {
    id: 'id',
    usageCount: 'usageCount',
    lastUsed: 'lastUsed',
    implementation: 'implementation',
    filePaths: 'filePaths',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tokenId: 'tokenId',
    teamId: 'teamId',
    applicationId: 'applicationId'
  };

  export type TokenUsageScalarFieldEnum = (typeof TokenUsageScalarFieldEnum)[keyof typeof TokenUsageScalarFieldEnum]


  export const PatternScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    name: 'name',
    description: 'description',
    complexity: 'complexity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatternScalarFieldEnum = (typeof PatternScalarFieldEnum)[keyof typeof PatternScalarFieldEnum]


  export const PatternTokenScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    tokenId: 'tokenId'
  };

  export type PatternTokenScalarFieldEnum = (typeof PatternTokenScalarFieldEnum)[keyof typeof PatternTokenScalarFieldEnum]


  export const PatternUsageScalarFieldEnum: {
    id: 'id',
    usageCount: 'usageCount',
    lastUsed: 'lastUsed',
    teams: 'teams',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    patternId: 'patternId'
  };

  export type PatternUsageScalarFieldEnum = (typeof PatternUsageScalarFieldEnum)[keyof typeof PatternUsageScalarFieldEnum]


  export const TokenDependencyScalarFieldEnum: {
    id: 'id',
    relationship: 'relationship',
    strength: 'strength',
    tokenId: 'tokenId',
    dependsOnId: 'dependsOnId'
  };

  export type TokenDependencyScalarFieldEnum = (typeof TokenDependencyScalarFieldEnum)[keyof typeof TokenDependencyScalarFieldEnum]


  export const ChangeRequestScalarFieldEnum: {
    id: 'id',
    type: 'type',
    proposedChanges: 'proposedChanges',
    reason: 'reason',
    impact: 'impact',
    status: 'status',
    testDeploymentId: 'testDeploymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tokenId: 'tokenId',
    requestedById: 'requestedById',
    approvedById: 'approvedById'
  };

  export type ChangeRequestScalarFieldEnum = (typeof ChangeRequestScalarFieldEnum)[keyof typeof ChangeRequestScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    priority: 'priority',
    isRead: 'isRead',
    channels: 'channels',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt',
    userId: 'userId',
    changeRequestId: 'changeRequestId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ScanResultScalarFieldEnum: {
    id: 'id',
    scanDate: 'scanDate',
    tokensFound: 'tokensFound',
    coverage: 'coverage',
    results: 'results',
    errors: 'errors',
    applicationId: 'applicationId'
  };

  export type ScanResultScalarFieldEnum = (typeof ScanResultScalarFieldEnum)[keyof typeof ScanResultScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'TokenCategory'
   */
  export type EnumTokenCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenCategory'>
    


  /**
   * Reference to a field of type 'TokenCategory[]'
   */
  export type ListEnumTokenCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenCategory[]'>
    


  /**
   * Reference to a field of type 'Criticality'
   */
  export type EnumCriticalityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Criticality'>
    


  /**
   * Reference to a field of type 'Criticality[]'
   */
  export type ListEnumCriticalityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Criticality[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DeprecationStatus'
   */
  export type EnumDeprecationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeprecationStatus'>
    


  /**
   * Reference to a field of type 'DeprecationStatus[]'
   */
  export type ListEnumDeprecationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeprecationStatus[]'>
    


  /**
   * Reference to a field of type 'AppType'
   */
  export type EnumAppTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppType'>
    


  /**
   * Reference to a field of type 'AppType[]'
   */
  export type ListEnumAppTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppType[]'>
    


  /**
   * Reference to a field of type 'AppStatus'
   */
  export type EnumAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppStatus'>
    


  /**
   * Reference to a field of type 'AppStatus[]'
   */
  export type ListEnumAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Implementation'
   */
  export type EnumImplementationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Implementation'>
    


  /**
   * Reference to a field of type 'Implementation[]'
   */
  export type ListEnumImplementationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Implementation[]'>
    


  /**
   * Reference to a field of type 'Complexity'
   */
  export type EnumComplexityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Complexity'>
    


  /**
   * Reference to a field of type 'Complexity[]'
   */
  export type ListEnumComplexityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Complexity[]'>
    


  /**
   * Reference to a field of type 'DependencyType'
   */
  export type EnumDependencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DependencyType'>
    


  /**
   * Reference to a field of type 'DependencyType[]'
   */
  export type ListEnumDependencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DependencyType[]'>
    


  /**
   * Reference to a field of type 'ChangeType'
   */
  export type EnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType'>
    


  /**
   * Reference to a field of type 'ChangeType[]'
   */
  export type ListEnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    team?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tokensCreated?: TokenListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
    approvals?: ChangeRequestListRelationFilter
    tokenHistory?: TokenHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    team?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokensCreated?: TokenOrderByRelationAggregateInput
    changeRequests?: ChangeRequestOrderByRelationAggregateInput
    approvals?: ChangeRequestOrderByRelationAggregateInput
    tokenHistory?: TokenHistoryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    team?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tokensCreated?: TokenListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
    approvals?: ChangeRequestListRelationFilter
    tokenHistory?: TokenHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    team?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    team?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    tokenId?: StringFilter<"Token"> | string
    name?: StringFilter<"Token"> | string
    currentVersion?: StringFilter<"Token"> | string
    value?: JsonFilter<"Token">
    category?: EnumTokenCategoryFilter<"Token"> | $Enums.TokenCategory
    criticality?: EnumCriticalityFilter<"Token"> | $Enums.Criticality
    reviewRequired?: BoolFilter<"Token"> | boolean
    deprecationStatus?: EnumDeprecationStatusFilter<"Token"> | $Enums.DeprecationStatus
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    creatorId?: StringFilter<"Token"> | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    history?: TokenHistoryListRelationFilter
    usages?: TokenUsageListRelationFilter
    patterns?: PatternTokenListRelationFilter
    dependencies?: TokenDependencyListRelationFilter
    dependents?: TokenDependencyListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    currentVersion?: SortOrder
    value?: SortOrder
    category?: SortOrder
    criticality?: SortOrder
    reviewRequired?: SortOrder
    deprecationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    creator?: UserOrderByWithRelationInput
    history?: TokenHistoryOrderByRelationAggregateInput
    usages?: TokenUsageOrderByRelationAggregateInput
    patterns?: PatternTokenOrderByRelationAggregateInput
    dependencies?: TokenDependencyOrderByRelationAggregateInput
    dependents?: TokenDependencyOrderByRelationAggregateInput
    changeRequests?: ChangeRequestOrderByRelationAggregateInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenId?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    name?: StringFilter<"Token"> | string
    currentVersion?: StringFilter<"Token"> | string
    value?: JsonFilter<"Token">
    category?: EnumTokenCategoryFilter<"Token"> | $Enums.TokenCategory
    criticality?: EnumCriticalityFilter<"Token"> | $Enums.Criticality
    reviewRequired?: BoolFilter<"Token"> | boolean
    deprecationStatus?: EnumDeprecationStatusFilter<"Token"> | $Enums.DeprecationStatus
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    creatorId?: StringFilter<"Token"> | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    history?: TokenHistoryListRelationFilter
    usages?: TokenUsageListRelationFilter
    patterns?: PatternTokenListRelationFilter
    dependencies?: TokenDependencyListRelationFilter
    dependents?: TokenDependencyListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
  }, "id" | "tokenId">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    currentVersion?: SortOrder
    value?: SortOrder
    category?: SortOrder
    criticality?: SortOrder
    reviewRequired?: SortOrder
    deprecationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    tokenId?: StringWithAggregatesFilter<"Token"> | string
    name?: StringWithAggregatesFilter<"Token"> | string
    currentVersion?: StringWithAggregatesFilter<"Token"> | string
    value?: JsonWithAggregatesFilter<"Token">
    category?: EnumTokenCategoryWithAggregatesFilter<"Token"> | $Enums.TokenCategory
    criticality?: EnumCriticalityWithAggregatesFilter<"Token"> | $Enums.Criticality
    reviewRequired?: BoolWithAggregatesFilter<"Token"> | boolean
    deprecationStatus?: EnumDeprecationStatusWithAggregatesFilter<"Token"> | $Enums.DeprecationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Token"> | string
  }

  export type TokenHistoryWhereInput = {
    AND?: TokenHistoryWhereInput | TokenHistoryWhereInput[]
    OR?: TokenHistoryWhereInput[]
    NOT?: TokenHistoryWhereInput | TokenHistoryWhereInput[]
    id?: StringFilter<"TokenHistory"> | string
    version?: StringFilter<"TokenHistory"> | string
    changes?: JsonFilter<"TokenHistory">
    changedAt?: DateTimeFilter<"TokenHistory"> | Date | string
    approvedAt?: DateTimeNullableFilter<"TokenHistory"> | Date | string | null
    rollbackInfo?: JsonNullableFilter<"TokenHistory">
    tokenId?: StringFilter<"TokenHistory"> | string
    changedById?: StringFilter<"TokenHistory"> | string
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    changedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TokenHistoryOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    changes?: SortOrder
    changedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rollbackInfo?: SortOrderInput | SortOrder
    tokenId?: SortOrder
    changedById?: SortOrder
    token?: TokenOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type TokenHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TokenHistoryWhereInput | TokenHistoryWhereInput[]
    OR?: TokenHistoryWhereInput[]
    NOT?: TokenHistoryWhereInput | TokenHistoryWhereInput[]
    version?: StringFilter<"TokenHistory"> | string
    changes?: JsonFilter<"TokenHistory">
    changedAt?: DateTimeFilter<"TokenHistory"> | Date | string
    approvedAt?: DateTimeNullableFilter<"TokenHistory"> | Date | string | null
    rollbackInfo?: JsonNullableFilter<"TokenHistory">
    tokenId?: StringFilter<"TokenHistory"> | string
    changedById?: StringFilter<"TokenHistory"> | string
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    changedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TokenHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    changes?: SortOrder
    changedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rollbackInfo?: SortOrderInput | SortOrder
    tokenId?: SortOrder
    changedById?: SortOrder
    _count?: TokenHistoryCountOrderByAggregateInput
    _max?: TokenHistoryMaxOrderByAggregateInput
    _min?: TokenHistoryMinOrderByAggregateInput
  }

  export type TokenHistoryScalarWhereWithAggregatesInput = {
    AND?: TokenHistoryScalarWhereWithAggregatesInput | TokenHistoryScalarWhereWithAggregatesInput[]
    OR?: TokenHistoryScalarWhereWithAggregatesInput[]
    NOT?: TokenHistoryScalarWhereWithAggregatesInput | TokenHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenHistory"> | string
    version?: StringWithAggregatesFilter<"TokenHistory"> | string
    changes?: JsonWithAggregatesFilter<"TokenHistory">
    changedAt?: DateTimeWithAggregatesFilter<"TokenHistory"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"TokenHistory"> | Date | string | null
    rollbackInfo?: JsonNullableWithAggregatesFilter<"TokenHistory">
    tokenId?: StringWithAggregatesFilter<"TokenHistory"> | string
    changedById?: StringWithAggregatesFilter<"TokenHistory"> | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    contactEmail?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    isActive?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    applications?: ApplicationListRelationFilter
    tokenUsages?: TokenUsageListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applications?: ApplicationOrderByRelationAggregateInput
    tokenUsages?: TokenUsageOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    contactEmail?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    isActive?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    applications?: ApplicationListRelationFilter
    tokenUsages?: TokenUsageListRelationFilter
  }, "id" | "name">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    contactEmail?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    isActive?: BoolWithAggregatesFilter<"Team"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    name?: StringFilter<"Application"> | string
    type?: EnumAppTypeFilter<"Application"> | $Enums.AppType
    domain?: StringNullableFilter<"Application"> | string | null
    repository?: StringNullableFilter<"Application"> | string | null
    status?: EnumAppStatusFilter<"Application"> | $Enums.AppStatus
    lastScanned?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    teamId?: StringFilter<"Application"> | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    tokenUsages?: TokenUsageListRelationFilter
    scanResults?: ScanResultListRelationFilter
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    domain?: SortOrderInput | SortOrder
    repository?: SortOrderInput | SortOrder
    status?: SortOrder
    lastScanned?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    team?: TeamOrderByWithRelationInput
    tokenUsages?: TokenUsageOrderByRelationAggregateInput
    scanResults?: ScanResultOrderByRelationAggregateInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    name?: StringFilter<"Application"> | string
    type?: EnumAppTypeFilter<"Application"> | $Enums.AppType
    domain?: StringNullableFilter<"Application"> | string | null
    repository?: StringNullableFilter<"Application"> | string | null
    status?: EnumAppStatusFilter<"Application"> | $Enums.AppStatus
    lastScanned?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    teamId?: StringFilter<"Application"> | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    tokenUsages?: TokenUsageListRelationFilter
    scanResults?: ScanResultListRelationFilter
  }, "id">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    domain?: SortOrderInput | SortOrder
    repository?: SortOrderInput | SortOrder
    status?: SortOrder
    lastScanned?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    name?: StringWithAggregatesFilter<"Application"> | string
    type?: EnumAppTypeWithAggregatesFilter<"Application"> | $Enums.AppType
    domain?: StringNullableWithAggregatesFilter<"Application"> | string | null
    repository?: StringNullableWithAggregatesFilter<"Application"> | string | null
    status?: EnumAppStatusWithAggregatesFilter<"Application"> | $Enums.AppStatus
    lastScanned?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    teamId?: StringWithAggregatesFilter<"Application"> | string
  }

  export type TokenUsageWhereInput = {
    AND?: TokenUsageWhereInput | TokenUsageWhereInput[]
    OR?: TokenUsageWhereInput[]
    NOT?: TokenUsageWhereInput | TokenUsageWhereInput[]
    id?: StringFilter<"TokenUsage"> | string
    usageCount?: IntFilter<"TokenUsage"> | number
    lastUsed?: DateTimeFilter<"TokenUsage"> | Date | string
    implementation?: EnumImplementationFilter<"TokenUsage"> | $Enums.Implementation
    filePaths?: StringNullableListFilter<"TokenUsage">
    createdAt?: DateTimeFilter<"TokenUsage"> | Date | string
    updatedAt?: DateTimeFilter<"TokenUsage"> | Date | string
    tokenId?: StringFilter<"TokenUsage"> | string
    teamId?: StringFilter<"TokenUsage"> | string
    applicationId?: StringFilter<"TokenUsage"> | string
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }

  export type TokenUsageOrderByWithRelationInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    implementation?: SortOrder
    filePaths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    teamId?: SortOrder
    applicationId?: SortOrder
    token?: TokenOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    application?: ApplicationOrderByWithRelationInput
  }

  export type TokenUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenId_teamId_applicationId?: TokenUsageTokenIdTeamIdApplicationIdCompoundUniqueInput
    AND?: TokenUsageWhereInput | TokenUsageWhereInput[]
    OR?: TokenUsageWhereInput[]
    NOT?: TokenUsageWhereInput | TokenUsageWhereInput[]
    usageCount?: IntFilter<"TokenUsage"> | number
    lastUsed?: DateTimeFilter<"TokenUsage"> | Date | string
    implementation?: EnumImplementationFilter<"TokenUsage"> | $Enums.Implementation
    filePaths?: StringNullableListFilter<"TokenUsage">
    createdAt?: DateTimeFilter<"TokenUsage"> | Date | string
    updatedAt?: DateTimeFilter<"TokenUsage"> | Date | string
    tokenId?: StringFilter<"TokenUsage"> | string
    teamId?: StringFilter<"TokenUsage"> | string
    applicationId?: StringFilter<"TokenUsage"> | string
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }, "id" | "tokenId_teamId_applicationId">

  export type TokenUsageOrderByWithAggregationInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    implementation?: SortOrder
    filePaths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    teamId?: SortOrder
    applicationId?: SortOrder
    _count?: TokenUsageCountOrderByAggregateInput
    _avg?: TokenUsageAvgOrderByAggregateInput
    _max?: TokenUsageMaxOrderByAggregateInput
    _min?: TokenUsageMinOrderByAggregateInput
    _sum?: TokenUsageSumOrderByAggregateInput
  }

  export type TokenUsageScalarWhereWithAggregatesInput = {
    AND?: TokenUsageScalarWhereWithAggregatesInput | TokenUsageScalarWhereWithAggregatesInput[]
    OR?: TokenUsageScalarWhereWithAggregatesInput[]
    NOT?: TokenUsageScalarWhereWithAggregatesInput | TokenUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenUsage"> | string
    usageCount?: IntWithAggregatesFilter<"TokenUsage"> | number
    lastUsed?: DateTimeWithAggregatesFilter<"TokenUsage"> | Date | string
    implementation?: EnumImplementationWithAggregatesFilter<"TokenUsage"> | $Enums.Implementation
    filePaths?: StringNullableListFilter<"TokenUsage">
    createdAt?: DateTimeWithAggregatesFilter<"TokenUsage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TokenUsage"> | Date | string
    tokenId?: StringWithAggregatesFilter<"TokenUsage"> | string
    teamId?: StringWithAggregatesFilter<"TokenUsage"> | string
    applicationId?: StringWithAggregatesFilter<"TokenUsage"> | string
  }

  export type PatternWhereInput = {
    AND?: PatternWhereInput | PatternWhereInput[]
    OR?: PatternWhereInput[]
    NOT?: PatternWhereInput | PatternWhereInput[]
    id?: StringFilter<"Pattern"> | string
    patternId?: StringFilter<"Pattern"> | string
    name?: StringFilter<"Pattern"> | string
    description?: StringNullableFilter<"Pattern"> | string | null
    complexity?: EnumComplexityFilter<"Pattern"> | $Enums.Complexity
    createdAt?: DateTimeFilter<"Pattern"> | Date | string
    updatedAt?: DateTimeFilter<"Pattern"> | Date | string
    tokens?: PatternTokenListRelationFilter
    usages?: PatternUsageListRelationFilter
  }

  export type PatternOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokens?: PatternTokenOrderByRelationAggregateInput
    usages?: PatternUsageOrderByRelationAggregateInput
  }

  export type PatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternId?: string
    AND?: PatternWhereInput | PatternWhereInput[]
    OR?: PatternWhereInput[]
    NOT?: PatternWhereInput | PatternWhereInput[]
    name?: StringFilter<"Pattern"> | string
    description?: StringNullableFilter<"Pattern"> | string | null
    complexity?: EnumComplexityFilter<"Pattern"> | $Enums.Complexity
    createdAt?: DateTimeFilter<"Pattern"> | Date | string
    updatedAt?: DateTimeFilter<"Pattern"> | Date | string
    tokens?: PatternTokenListRelationFilter
    usages?: PatternUsageListRelationFilter
  }, "id" | "patternId">

  export type PatternOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatternCountOrderByAggregateInput
    _max?: PatternMaxOrderByAggregateInput
    _min?: PatternMinOrderByAggregateInput
  }

  export type PatternScalarWhereWithAggregatesInput = {
    AND?: PatternScalarWhereWithAggregatesInput | PatternScalarWhereWithAggregatesInput[]
    OR?: PatternScalarWhereWithAggregatesInput[]
    NOT?: PatternScalarWhereWithAggregatesInput | PatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pattern"> | string
    patternId?: StringWithAggregatesFilter<"Pattern"> | string
    name?: StringWithAggregatesFilter<"Pattern"> | string
    description?: StringNullableWithAggregatesFilter<"Pattern"> | string | null
    complexity?: EnumComplexityWithAggregatesFilter<"Pattern"> | $Enums.Complexity
    createdAt?: DateTimeWithAggregatesFilter<"Pattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pattern"> | Date | string
  }

  export type PatternTokenWhereInput = {
    AND?: PatternTokenWhereInput | PatternTokenWhereInput[]
    OR?: PatternTokenWhereInput[]
    NOT?: PatternTokenWhereInput | PatternTokenWhereInput[]
    id?: StringFilter<"PatternToken"> | string
    patternId?: StringFilter<"PatternToken"> | string
    tokenId?: StringFilter<"PatternToken"> | string
    pattern?: XOR<PatternRelationFilter, PatternWhereInput>
    token?: XOR<TokenRelationFilter, TokenWhereInput>
  }

  export type PatternTokenOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    tokenId?: SortOrder
    pattern?: PatternOrderByWithRelationInput
    token?: TokenOrderByWithRelationInput
  }

  export type PatternTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternId_tokenId?: PatternTokenPatternIdTokenIdCompoundUniqueInput
    AND?: PatternTokenWhereInput | PatternTokenWhereInput[]
    OR?: PatternTokenWhereInput[]
    NOT?: PatternTokenWhereInput | PatternTokenWhereInput[]
    patternId?: StringFilter<"PatternToken"> | string
    tokenId?: StringFilter<"PatternToken"> | string
    pattern?: XOR<PatternRelationFilter, PatternWhereInput>
    token?: XOR<TokenRelationFilter, TokenWhereInput>
  }, "id" | "patternId_tokenId">

  export type PatternTokenOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    tokenId?: SortOrder
    _count?: PatternTokenCountOrderByAggregateInput
    _max?: PatternTokenMaxOrderByAggregateInput
    _min?: PatternTokenMinOrderByAggregateInput
  }

  export type PatternTokenScalarWhereWithAggregatesInput = {
    AND?: PatternTokenScalarWhereWithAggregatesInput | PatternTokenScalarWhereWithAggregatesInput[]
    OR?: PatternTokenScalarWhereWithAggregatesInput[]
    NOT?: PatternTokenScalarWhereWithAggregatesInput | PatternTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatternToken"> | string
    patternId?: StringWithAggregatesFilter<"PatternToken"> | string
    tokenId?: StringWithAggregatesFilter<"PatternToken"> | string
  }

  export type PatternUsageWhereInput = {
    AND?: PatternUsageWhereInput | PatternUsageWhereInput[]
    OR?: PatternUsageWhereInput[]
    NOT?: PatternUsageWhereInput | PatternUsageWhereInput[]
    id?: StringFilter<"PatternUsage"> | string
    usageCount?: IntFilter<"PatternUsage"> | number
    lastUsed?: DateTimeFilter<"PatternUsage"> | Date | string
    teams?: StringNullableListFilter<"PatternUsage">
    createdAt?: DateTimeFilter<"PatternUsage"> | Date | string
    updatedAt?: DateTimeFilter<"PatternUsage"> | Date | string
    patternId?: StringFilter<"PatternUsage"> | string
    pattern?: XOR<PatternRelationFilter, PatternWhereInput>
  }

  export type PatternUsageOrderByWithRelationInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    teams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patternId?: SortOrder
    pattern?: PatternOrderByWithRelationInput
  }

  export type PatternUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatternUsageWhereInput | PatternUsageWhereInput[]
    OR?: PatternUsageWhereInput[]
    NOT?: PatternUsageWhereInput | PatternUsageWhereInput[]
    usageCount?: IntFilter<"PatternUsage"> | number
    lastUsed?: DateTimeFilter<"PatternUsage"> | Date | string
    teams?: StringNullableListFilter<"PatternUsage">
    createdAt?: DateTimeFilter<"PatternUsage"> | Date | string
    updatedAt?: DateTimeFilter<"PatternUsage"> | Date | string
    patternId?: StringFilter<"PatternUsage"> | string
    pattern?: XOR<PatternRelationFilter, PatternWhereInput>
  }, "id">

  export type PatternUsageOrderByWithAggregationInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    teams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patternId?: SortOrder
    _count?: PatternUsageCountOrderByAggregateInput
    _avg?: PatternUsageAvgOrderByAggregateInput
    _max?: PatternUsageMaxOrderByAggregateInput
    _min?: PatternUsageMinOrderByAggregateInput
    _sum?: PatternUsageSumOrderByAggregateInput
  }

  export type PatternUsageScalarWhereWithAggregatesInput = {
    AND?: PatternUsageScalarWhereWithAggregatesInput | PatternUsageScalarWhereWithAggregatesInput[]
    OR?: PatternUsageScalarWhereWithAggregatesInput[]
    NOT?: PatternUsageScalarWhereWithAggregatesInput | PatternUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatternUsage"> | string
    usageCount?: IntWithAggregatesFilter<"PatternUsage"> | number
    lastUsed?: DateTimeWithAggregatesFilter<"PatternUsage"> | Date | string
    teams?: StringNullableListFilter<"PatternUsage">
    createdAt?: DateTimeWithAggregatesFilter<"PatternUsage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatternUsage"> | Date | string
    patternId?: StringWithAggregatesFilter<"PatternUsage"> | string
  }

  export type TokenDependencyWhereInput = {
    AND?: TokenDependencyWhereInput | TokenDependencyWhereInput[]
    OR?: TokenDependencyWhereInput[]
    NOT?: TokenDependencyWhereInput | TokenDependencyWhereInput[]
    id?: StringFilter<"TokenDependency"> | string
    relationship?: EnumDependencyTypeFilter<"TokenDependency"> | $Enums.DependencyType
    strength?: IntFilter<"TokenDependency"> | number
    tokenId?: StringFilter<"TokenDependency"> | string
    dependsOnId?: StringFilter<"TokenDependency"> | string
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    dependsOn?: XOR<TokenRelationFilter, TokenWhereInput>
  }

  export type TokenDependencyOrderByWithRelationInput = {
    id?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    tokenId?: SortOrder
    dependsOnId?: SortOrder
    token?: TokenOrderByWithRelationInput
    dependsOn?: TokenOrderByWithRelationInput
  }

  export type TokenDependencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenId_dependsOnId?: TokenDependencyTokenIdDependsOnIdCompoundUniqueInput
    AND?: TokenDependencyWhereInput | TokenDependencyWhereInput[]
    OR?: TokenDependencyWhereInput[]
    NOT?: TokenDependencyWhereInput | TokenDependencyWhereInput[]
    relationship?: EnumDependencyTypeFilter<"TokenDependency"> | $Enums.DependencyType
    strength?: IntFilter<"TokenDependency"> | number
    tokenId?: StringFilter<"TokenDependency"> | string
    dependsOnId?: StringFilter<"TokenDependency"> | string
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    dependsOn?: XOR<TokenRelationFilter, TokenWhereInput>
  }, "id" | "tokenId_dependsOnId">

  export type TokenDependencyOrderByWithAggregationInput = {
    id?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    tokenId?: SortOrder
    dependsOnId?: SortOrder
    _count?: TokenDependencyCountOrderByAggregateInput
    _avg?: TokenDependencyAvgOrderByAggregateInput
    _max?: TokenDependencyMaxOrderByAggregateInput
    _min?: TokenDependencyMinOrderByAggregateInput
    _sum?: TokenDependencySumOrderByAggregateInput
  }

  export type TokenDependencyScalarWhereWithAggregatesInput = {
    AND?: TokenDependencyScalarWhereWithAggregatesInput | TokenDependencyScalarWhereWithAggregatesInput[]
    OR?: TokenDependencyScalarWhereWithAggregatesInput[]
    NOT?: TokenDependencyScalarWhereWithAggregatesInput | TokenDependencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenDependency"> | string
    relationship?: EnumDependencyTypeWithAggregatesFilter<"TokenDependency"> | $Enums.DependencyType
    strength?: IntWithAggregatesFilter<"TokenDependency"> | number
    tokenId?: StringWithAggregatesFilter<"TokenDependency"> | string
    dependsOnId?: StringWithAggregatesFilter<"TokenDependency"> | string
  }

  export type ChangeRequestWhereInput = {
    AND?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    OR?: ChangeRequestWhereInput[]
    NOT?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    id?: StringFilter<"ChangeRequest"> | string
    type?: EnumChangeTypeFilter<"ChangeRequest"> | $Enums.ChangeType
    proposedChanges?: JsonFilter<"ChangeRequest">
    reason?: StringFilter<"ChangeRequest"> | string
    impact?: JsonFilter<"ChangeRequest">
    status?: EnumRequestStatusFilter<"ChangeRequest"> | $Enums.RequestStatus
    testDeploymentId?: StringNullableFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    tokenId?: StringFilter<"ChangeRequest"> | string
    requestedById?: StringFilter<"ChangeRequest"> | string
    approvedById?: StringNullableFilter<"ChangeRequest"> | string | null
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type ChangeRequestOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    proposedChanges?: SortOrder
    reason?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    testDeploymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    token?: TokenOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type ChangeRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    OR?: ChangeRequestWhereInput[]
    NOT?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    type?: EnumChangeTypeFilter<"ChangeRequest"> | $Enums.ChangeType
    proposedChanges?: JsonFilter<"ChangeRequest">
    reason?: StringFilter<"ChangeRequest"> | string
    impact?: JsonFilter<"ChangeRequest">
    status?: EnumRequestStatusFilter<"ChangeRequest"> | $Enums.RequestStatus
    testDeploymentId?: StringNullableFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    tokenId?: StringFilter<"ChangeRequest"> | string
    requestedById?: StringFilter<"ChangeRequest"> | string
    approvedById?: StringNullableFilter<"ChangeRequest"> | string | null
    token?: XOR<TokenRelationFilter, TokenWhereInput>
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id">

  export type ChangeRequestOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    proposedChanges?: SortOrder
    reason?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    testDeploymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    _count?: ChangeRequestCountOrderByAggregateInput
    _max?: ChangeRequestMaxOrderByAggregateInput
    _min?: ChangeRequestMinOrderByAggregateInput
  }

  export type ChangeRequestScalarWhereWithAggregatesInput = {
    AND?: ChangeRequestScalarWhereWithAggregatesInput | ChangeRequestScalarWhereWithAggregatesInput[]
    OR?: ChangeRequestScalarWhereWithAggregatesInput[]
    NOT?: ChangeRequestScalarWhereWithAggregatesInput | ChangeRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChangeRequest"> | string
    type?: EnumChangeTypeWithAggregatesFilter<"ChangeRequest"> | $Enums.ChangeType
    proposedChanges?: JsonWithAggregatesFilter<"ChangeRequest">
    reason?: StringWithAggregatesFilter<"ChangeRequest"> | string
    impact?: JsonWithAggregatesFilter<"ChangeRequest">
    status?: EnumRequestStatusWithAggregatesFilter<"ChangeRequest"> | $Enums.RequestStatus
    testDeploymentId?: StringNullableWithAggregatesFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChangeRequest"> | Date | string
    tokenId?: StringWithAggregatesFilter<"ChangeRequest"> | string
    requestedById?: StringWithAggregatesFilter<"ChangeRequest"> | string
    approvedById?: StringNullableWithAggregatesFilter<"ChangeRequest"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumPriorityFilter<"Notification"> | $Enums.Priority
    isRead?: BoolFilter<"Notification"> | boolean
    channels?: StringNullableListFilter<"Notification">
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    userId?: StringFilter<"Notification"> | string
    changeRequestId?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    changeRequest?: XOR<ChangeRequestNullableRelationFilter, ChangeRequestWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    channels?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    changeRequestId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    changeRequest?: ChangeRequestOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumPriorityFilter<"Notification"> | $Enums.Priority
    isRead?: BoolFilter<"Notification"> | boolean
    channels?: StringNullableListFilter<"Notification">
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    userId?: StringFilter<"Notification"> | string
    changeRequestId?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    changeRequest?: XOR<ChangeRequestNullableRelationFilter, ChangeRequestWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    channels?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    changeRequestId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumPriorityWithAggregatesFilter<"Notification"> | $Enums.Priority
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    channels?: StringNullableListFilter<"Notification">
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
    changeRequestId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type ScanResultWhereInput = {
    AND?: ScanResultWhereInput | ScanResultWhereInput[]
    OR?: ScanResultWhereInput[]
    NOT?: ScanResultWhereInput | ScanResultWhereInput[]
    id?: StringFilter<"ScanResult"> | string
    scanDate?: DateTimeFilter<"ScanResult"> | Date | string
    tokensFound?: IntFilter<"ScanResult"> | number
    coverage?: FloatFilter<"ScanResult"> | number
    results?: JsonFilter<"ScanResult">
    errors?: StringNullableListFilter<"ScanResult">
    applicationId?: StringFilter<"ScanResult"> | string
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }

  export type ScanResultOrderByWithRelationInput = {
    id?: SortOrder
    scanDate?: SortOrder
    tokensFound?: SortOrder
    coverage?: SortOrder
    results?: SortOrder
    errors?: SortOrder
    applicationId?: SortOrder
    application?: ApplicationOrderByWithRelationInput
  }

  export type ScanResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScanResultWhereInput | ScanResultWhereInput[]
    OR?: ScanResultWhereInput[]
    NOT?: ScanResultWhereInput | ScanResultWhereInput[]
    scanDate?: DateTimeFilter<"ScanResult"> | Date | string
    tokensFound?: IntFilter<"ScanResult"> | number
    coverage?: FloatFilter<"ScanResult"> | number
    results?: JsonFilter<"ScanResult">
    errors?: StringNullableListFilter<"ScanResult">
    applicationId?: StringFilter<"ScanResult"> | string
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }, "id">

  export type ScanResultOrderByWithAggregationInput = {
    id?: SortOrder
    scanDate?: SortOrder
    tokensFound?: SortOrder
    coverage?: SortOrder
    results?: SortOrder
    errors?: SortOrder
    applicationId?: SortOrder
    _count?: ScanResultCountOrderByAggregateInput
    _avg?: ScanResultAvgOrderByAggregateInput
    _max?: ScanResultMaxOrderByAggregateInput
    _min?: ScanResultMinOrderByAggregateInput
    _sum?: ScanResultSumOrderByAggregateInput
  }

  export type ScanResultScalarWhereWithAggregatesInput = {
    AND?: ScanResultScalarWhereWithAggregatesInput | ScanResultScalarWhereWithAggregatesInput[]
    OR?: ScanResultScalarWhereWithAggregatesInput[]
    NOT?: ScanResultScalarWhereWithAggregatesInput | ScanResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScanResult"> | string
    scanDate?: DateTimeWithAggregatesFilter<"ScanResult"> | Date | string
    tokensFound?: IntWithAggregatesFilter<"ScanResult"> | number
    coverage?: FloatWithAggregatesFilter<"ScanResult"> | number
    results?: JsonWithAggregatesFilter<"ScanResult">
    errors?: StringNullableListFilter<"ScanResult">
    applicationId?: StringWithAggregatesFilter<"ScanResult"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryCreateNestedManyWithoutChangedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestUncheckedCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryUncheckedCreateNestedManyWithoutChangedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenCreateManyInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenHistoryCreateInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    token: TokenCreateNestedOneWithoutHistoryInput
    changedBy: UserCreateNestedOneWithoutTokenHistoryInput
  }

  export type TokenHistoryUncheckedCreateInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId: string
    changedById: string
  }

  export type TokenHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    token?: TokenUpdateOneRequiredWithoutHistoryNestedInput
    changedBy?: UserUpdateOneRequiredWithoutTokenHistoryNestedInput
  }

  export type TokenHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type TokenHistoryCreateManyInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId: string
    changedById: string
  }

  export type TokenHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TokenHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId?: StringFieldUpdateOperationsInput | string
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationCreateNestedManyWithoutTeamInput
    tokenUsages?: TokenUsageCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutTeamInput
    tokenUsages?: TokenUsageUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUpdateManyWithoutTeamNestedInput
    tokenUsages?: TokenUsageUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutTeamNestedInput
    tokenUsages?: TokenUsageUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutApplicationsInput
    tokenUsages?: TokenUsageCreateNestedManyWithoutApplicationInput
    scanResults?: ScanResultCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    tokenUsages?: TokenUsageUncheckedCreateNestedManyWithoutApplicationInput
    scanResults?: ScanResultUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutApplicationsNestedInput
    tokenUsages?: TokenUsageUpdateManyWithoutApplicationNestedInput
    scanResults?: ScanResultUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    tokenUsages?: TokenUsageUncheckedUpdateManyWithoutApplicationNestedInput
    scanResults?: ScanResultUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateManyInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageCreateInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutUsagesInput
    team: TeamCreateNestedOneWithoutTokenUsagesInput
    application: ApplicationCreateNestedOneWithoutTokenUsagesInput
  }

  export type TokenUsageUncheckedCreateInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    teamId: string
    applicationId: string
  }

  export type TokenUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutUsagesNestedInput
    team?: TeamUpdateOneRequiredWithoutTokenUsagesNestedInput
    application?: ApplicationUpdateOneRequiredWithoutTokenUsagesNestedInput
  }

  export type TokenUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageCreateManyInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    teamId: string
    applicationId: string
  }

  export type TokenUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternCreateInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: PatternTokenCreateNestedManyWithoutPatternInput
    usages?: PatternUsageCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: PatternTokenUncheckedCreateNestedManyWithoutPatternInput
    usages?: PatternUsageUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: PatternTokenUpdateManyWithoutPatternNestedInput
    usages?: PatternUsageUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: PatternTokenUncheckedUpdateManyWithoutPatternNestedInput
    usages?: PatternUsageUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type PatternCreateManyInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTokenCreateInput = {
    id?: string
    pattern: PatternCreateNestedOneWithoutTokensInput
    token: TokenCreateNestedOneWithoutPatternsInput
  }

  export type PatternTokenUncheckedCreateInput = {
    id?: string
    patternId: string
    tokenId: string
  }

  export type PatternTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pattern?: PatternUpdateOneRequiredWithoutTokensNestedInput
    token?: TokenUpdateOneRequiredWithoutPatternsNestedInput
  }

  export type PatternTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternTokenCreateManyInput = {
    id?: string
    patternId: string
    tokenId: string
  }

  export type PatternTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PatternTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternUsageCreateInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    teams?: PatternUsageCreateteamsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pattern: PatternCreateNestedOneWithoutUsagesInput
  }

  export type PatternUsageUncheckedCreateInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    teams?: PatternUsageCreateteamsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    patternId: string
  }

  export type PatternUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: PatternUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type PatternUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternUsageCreateManyInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    teams?: PatternUsageCreateteamsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    patternId: string
  }

  export type PatternUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenDependencyCreateInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    token: TokenCreateNestedOneWithoutDependenciesInput
    dependsOn: TokenCreateNestedOneWithoutDependentsInput
  }

  export type TokenDependencyUncheckedCreateInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    tokenId: string
    dependsOnId: string
  }

  export type TokenDependencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    token?: TokenUpdateOneRequiredWithoutDependenciesNestedInput
    dependsOn?: TokenUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TokenDependencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    tokenId?: StringFieldUpdateOperationsInput | string
    dependsOnId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenDependencyCreateManyInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    tokenId: string
    dependsOnId: string
  }

  export type TokenDependencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
  }

  export type TokenDependencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    tokenId?: StringFieldUpdateOperationsInput | string
    dependsOnId?: StringFieldUpdateOperationsInput | string
  }

  export type ChangeRequestCreateInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutChangeRequestsInput
    requestedBy: UserCreateNestedOneWithoutChangeRequestsInput
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput
    notifications?: NotificationCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    requestedById: string
    approvedById?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutChangeRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput
    notifications?: NotificationUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestCreateManyInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    requestedById: string
    approvedById?: string | null
  }

  export type ChangeRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
    changeRequest?: ChangeRequestCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    userId: string
    changeRequestId?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    changeRequest?: ChangeRequestUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    changeRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    userId: string
    changeRequestId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    changeRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScanResultCreateInput = {
    id?: string
    scanDate?: Date | string
    tokensFound?: number
    coverage?: number
    results: JsonNullValueInput | InputJsonValue
    errors?: ScanResultCreateerrorsInput | string[]
    application: ApplicationCreateNestedOneWithoutScanResultsInput
  }

  export type ScanResultUncheckedCreateInput = {
    id?: string
    scanDate?: Date | string
    tokensFound?: number
    coverage?: number
    results: JsonNullValueInput | InputJsonValue
    errors?: ScanResultCreateerrorsInput | string[]
    applicationId: string
  }

  export type ScanResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
    application?: ApplicationUpdateOneRequiredWithoutScanResultsNestedInput
  }

  export type ScanResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type ScanResultCreateManyInput = {
    id?: string
    scanDate?: Date | string
    tokensFound?: number
    coverage?: number
    results: JsonNullValueInput | InputJsonValue
    errors?: ScanResultCreateerrorsInput | string[]
    applicationId: string
  }

  export type ScanResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
  }

  export type ScanResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type ChangeRequestListRelationFilter = {
    every?: ChangeRequestWhereInput
    some?: ChangeRequestWhereInput
    none?: ChangeRequestWhereInput
  }

  export type TokenHistoryListRelationFilter = {
    every?: TokenHistoryWhereInput
    some?: TokenHistoryWhereInput
    none?: TokenHistoryWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    team?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    team?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    team?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumTokenCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenCategory | EnumTokenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenCategoryFilter<$PrismaModel> | $Enums.TokenCategory
  }

  export type EnumCriticalityFilter<$PrismaModel = never> = {
    equals?: $Enums.Criticality | EnumCriticalityFieldRefInput<$PrismaModel>
    in?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    not?: NestedEnumCriticalityFilter<$PrismaModel> | $Enums.Criticality
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumDeprecationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeprecationStatus | EnumDeprecationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeprecationStatusFilter<$PrismaModel> | $Enums.DeprecationStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TokenUsageListRelationFilter = {
    every?: TokenUsageWhereInput
    some?: TokenUsageWhereInput
    none?: TokenUsageWhereInput
  }

  export type PatternTokenListRelationFilter = {
    every?: PatternTokenWhereInput
    some?: PatternTokenWhereInput
    none?: PatternTokenWhereInput
  }

  export type TokenDependencyListRelationFilter = {
    every?: TokenDependencyWhereInput
    some?: TokenDependencyWhereInput
    none?: TokenDependencyWhereInput
  }

  export type TokenUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatternTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenDependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    currentVersion?: SortOrder
    value?: SortOrder
    category?: SortOrder
    criticality?: SortOrder
    reviewRequired?: SortOrder
    deprecationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    currentVersion?: SortOrder
    category?: SortOrder
    criticality?: SortOrder
    reviewRequired?: SortOrder
    deprecationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    currentVersion?: SortOrder
    category?: SortOrder
    criticality?: SortOrder
    reviewRequired?: SortOrder
    deprecationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumTokenCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenCategory | EnumTokenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TokenCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenCategoryFilter<$PrismaModel>
    _max?: NestedEnumTokenCategoryFilter<$PrismaModel>
  }

  export type EnumCriticalityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Criticality | EnumCriticalityFieldRefInput<$PrismaModel>
    in?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    not?: NestedEnumCriticalityWithAggregatesFilter<$PrismaModel> | $Enums.Criticality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCriticalityFilter<$PrismaModel>
    _max?: NestedEnumCriticalityFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumDeprecationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeprecationStatus | EnumDeprecationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeprecationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeprecationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeprecationStatusFilter<$PrismaModel>
    _max?: NestedEnumDeprecationStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TokenRelationFilter = {
    is?: TokenWhereInput
    isNot?: TokenWhereInput
  }

  export type TokenHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    changes?: SortOrder
    changedAt?: SortOrder
    approvedAt?: SortOrder
    rollbackInfo?: SortOrder
    tokenId?: SortOrder
    changedById?: SortOrder
  }

  export type TokenHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    changedAt?: SortOrder
    approvedAt?: SortOrder
    tokenId?: SortOrder
    changedById?: SortOrder
  }

  export type TokenHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    changedAt?: SortOrder
    approvedAt?: SortOrder
    tokenId?: SortOrder
    changedById?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactEmail?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppType | EnumAppTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppTypeFilter<$PrismaModel> | $Enums.AppType
  }

  export type EnumAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusFilter<$PrismaModel> | $Enums.AppStatus
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type ScanResultListRelationFilter = {
    every?: ScanResultWhereInput
    some?: ScanResultWhereInput
    none?: ScanResultWhereInput
  }

  export type ScanResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    domain?: SortOrder
    repository?: SortOrder
    status?: SortOrder
    lastScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    domain?: SortOrder
    repository?: SortOrder
    status?: SortOrder
    lastScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    domain?: SortOrder
    repository?: SortOrder
    status?: SortOrder
    lastScanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
  }

  export type EnumAppTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppType | EnumAppTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppTypeFilter<$PrismaModel>
    _max?: NestedEnumAppTypeFilter<$PrismaModel>
  }

  export type EnumAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppStatusFilter<$PrismaModel>
    _max?: NestedEnumAppStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumImplementationFilter<$PrismaModel = never> = {
    equals?: $Enums.Implementation | EnumImplementationFieldRefInput<$PrismaModel>
    in?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    not?: NestedEnumImplementationFilter<$PrismaModel> | $Enums.Implementation
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ApplicationRelationFilter = {
    is?: ApplicationWhereInput
    isNot?: ApplicationWhereInput
  }

  export type TokenUsageTokenIdTeamIdApplicationIdCompoundUniqueInput = {
    tokenId: string
    teamId: string
    applicationId: string
  }

  export type TokenUsageCountOrderByAggregateInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    implementation?: SortOrder
    filePaths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    teamId?: SortOrder
    applicationId?: SortOrder
  }

  export type TokenUsageAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type TokenUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    implementation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    teamId?: SortOrder
    applicationId?: SortOrder
  }

  export type TokenUsageMinOrderByAggregateInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    implementation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    teamId?: SortOrder
    applicationId?: SortOrder
  }

  export type TokenUsageSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumImplementationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Implementation | EnumImplementationFieldRefInput<$PrismaModel>
    in?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    not?: NestedEnumImplementationWithAggregatesFilter<$PrismaModel> | $Enums.Implementation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImplementationFilter<$PrismaModel>
    _max?: NestedEnumImplementationFilter<$PrismaModel>
  }

  export type EnumComplexityFilter<$PrismaModel = never> = {
    equals?: $Enums.Complexity | EnumComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityFilter<$PrismaModel> | $Enums.Complexity
  }

  export type PatternUsageListRelationFilter = {
    every?: PatternUsageWhereInput
    some?: PatternUsageWhereInput
    none?: PatternUsageWhereInput
  }

  export type PatternUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatternCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatternMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatternMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumComplexityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Complexity | EnumComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityWithAggregatesFilter<$PrismaModel> | $Enums.Complexity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplexityFilter<$PrismaModel>
    _max?: NestedEnumComplexityFilter<$PrismaModel>
  }

  export type PatternRelationFilter = {
    is?: PatternWhereInput
    isNot?: PatternWhereInput
  }

  export type PatternTokenPatternIdTokenIdCompoundUniqueInput = {
    patternId: string
    tokenId: string
  }

  export type PatternTokenCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    tokenId?: SortOrder
  }

  export type PatternTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    tokenId?: SortOrder
  }

  export type PatternTokenMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    tokenId?: SortOrder
  }

  export type PatternUsageCountOrderByAggregateInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    teams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patternId?: SortOrder
  }

  export type PatternUsageAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type PatternUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patternId?: SortOrder
  }

  export type PatternUsageMinOrderByAggregateInput = {
    id?: SortOrder
    usageCount?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patternId?: SortOrder
  }

  export type PatternUsageSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EnumDependencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DependencyType | EnumDependencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDependencyTypeFilter<$PrismaModel> | $Enums.DependencyType
  }

  export type TokenDependencyTokenIdDependsOnIdCompoundUniqueInput = {
    tokenId: string
    dependsOnId: string
  }

  export type TokenDependencyCountOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    tokenId?: SortOrder
    dependsOnId?: SortOrder
  }

  export type TokenDependencyAvgOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type TokenDependencyMaxOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    tokenId?: SortOrder
    dependsOnId?: SortOrder
  }

  export type TokenDependencyMinOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    tokenId?: SortOrder
    dependsOnId?: SortOrder
  }

  export type TokenDependencySumOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type EnumDependencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DependencyType | EnumDependencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDependencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.DependencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDependencyTypeFilter<$PrismaModel>
    _max?: NestedEnumDependencyTypeFilter<$PrismaModel>
  }

  export type EnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ChangeRequestCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    proposedChanges?: SortOrder
    reason?: SortOrder
    impact?: SortOrder
    status?: SortOrder
    testDeploymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
  }

  export type ChangeRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    testDeploymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
  }

  export type ChangeRequestMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    testDeploymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokenId?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
  }

  export type EnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type ChangeRequestNullableRelationFilter = {
    is?: ChangeRequestWhereInput | null
    isNot?: ChangeRequestWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    channels?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    userId?: SortOrder
    changeRequestId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    userId?: SortOrder
    changeRequestId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    userId?: SortOrder
    changeRequestId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ScanResultCountOrderByAggregateInput = {
    id?: SortOrder
    scanDate?: SortOrder
    tokensFound?: SortOrder
    coverage?: SortOrder
    results?: SortOrder
    errors?: SortOrder
    applicationId?: SortOrder
  }

  export type ScanResultAvgOrderByAggregateInput = {
    tokensFound?: SortOrder
    coverage?: SortOrder
  }

  export type ScanResultMaxOrderByAggregateInput = {
    id?: SortOrder
    scanDate?: SortOrder
    tokensFound?: SortOrder
    coverage?: SortOrder
    applicationId?: SortOrder
  }

  export type ScanResultMinOrderByAggregateInput = {
    id?: SortOrder
    scanDate?: SortOrder
    tokensFound?: SortOrder
    coverage?: SortOrder
    applicationId?: SortOrder
  }

  export type ScanResultSumOrderByAggregateInput = {
    tokensFound?: SortOrder
    coverage?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TokenCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type ChangeRequestCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<ChangeRequestCreateWithoutRequestedByInput, ChangeRequestUncheckedCreateWithoutRequestedByInput> | ChangeRequestCreateWithoutRequestedByInput[] | ChangeRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequestedByInput | ChangeRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: ChangeRequestCreateManyRequestedByInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type ChangeRequestCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ChangeRequestCreateWithoutApprovedByInput, ChangeRequestUncheckedCreateWithoutApprovedByInput> | ChangeRequestCreateWithoutApprovedByInput[] | ChangeRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutApprovedByInput | ChangeRequestCreateOrConnectWithoutApprovedByInput[]
    createMany?: ChangeRequestCreateManyApprovedByInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type TokenHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<TokenHistoryCreateWithoutChangedByInput, TokenHistoryUncheckedCreateWithoutChangedByInput> | TokenHistoryCreateWithoutChangedByInput[] | TokenHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutChangedByInput | TokenHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: TokenHistoryCreateManyChangedByInputEnvelope
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type ChangeRequestUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<ChangeRequestCreateWithoutRequestedByInput, ChangeRequestUncheckedCreateWithoutRequestedByInput> | ChangeRequestCreateWithoutRequestedByInput[] | ChangeRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequestedByInput | ChangeRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: ChangeRequestCreateManyRequestedByInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type ChangeRequestUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<ChangeRequestCreateWithoutApprovedByInput, ChangeRequestUncheckedCreateWithoutApprovedByInput> | ChangeRequestCreateWithoutApprovedByInput[] | ChangeRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutApprovedByInput | ChangeRequestCreateOrConnectWithoutApprovedByInput[]
    createMany?: ChangeRequestCreateManyApprovedByInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type TokenHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<TokenHistoryCreateWithoutChangedByInput, TokenHistoryUncheckedCreateWithoutChangedByInput> | TokenHistoryCreateWithoutChangedByInput[] | TokenHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutChangedByInput | TokenHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: TokenHistoryCreateManyChangedByInputEnvelope
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TokenUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutCreatorInput | TokenUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutCreatorInput | TokenUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutCreatorInput | TokenUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type ChangeRequestUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutRequestedByInput, ChangeRequestUncheckedCreateWithoutRequestedByInput> | ChangeRequestCreateWithoutRequestedByInput[] | ChangeRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequestedByInput | ChangeRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutRequestedByInput | ChangeRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: ChangeRequestCreateManyRequestedByInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutRequestedByInput | ChangeRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutRequestedByInput | ChangeRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type ChangeRequestUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutApprovedByInput, ChangeRequestUncheckedCreateWithoutApprovedByInput> | ChangeRequestCreateWithoutApprovedByInput[] | ChangeRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutApprovedByInput | ChangeRequestCreateOrConnectWithoutApprovedByInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutApprovedByInput | ChangeRequestUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ChangeRequestCreateManyApprovedByInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutApprovedByInput | ChangeRequestUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutApprovedByInput | ChangeRequestUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type TokenHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<TokenHistoryCreateWithoutChangedByInput, TokenHistoryUncheckedCreateWithoutChangedByInput> | TokenHistoryCreateWithoutChangedByInput[] | TokenHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutChangedByInput | TokenHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: TokenHistoryUpsertWithWhereUniqueWithoutChangedByInput | TokenHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: TokenHistoryCreateManyChangedByInputEnvelope
    set?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    disconnect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    delete?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    update?: TokenHistoryUpdateWithWhereUniqueWithoutChangedByInput | TokenHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: TokenHistoryUpdateManyWithWhereWithoutChangedByInput | TokenHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: TokenHistoryScalarWhereInput | TokenHistoryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutCreatorInput | TokenUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutCreatorInput | TokenUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutCreatorInput | TokenUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type ChangeRequestUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutRequestedByInput, ChangeRequestUncheckedCreateWithoutRequestedByInput> | ChangeRequestCreateWithoutRequestedByInput[] | ChangeRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequestedByInput | ChangeRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutRequestedByInput | ChangeRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: ChangeRequestCreateManyRequestedByInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutRequestedByInput | ChangeRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutRequestedByInput | ChangeRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type ChangeRequestUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutApprovedByInput, ChangeRequestUncheckedCreateWithoutApprovedByInput> | ChangeRequestCreateWithoutApprovedByInput[] | ChangeRequestUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutApprovedByInput | ChangeRequestCreateOrConnectWithoutApprovedByInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutApprovedByInput | ChangeRequestUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: ChangeRequestCreateManyApprovedByInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutApprovedByInput | ChangeRequestUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutApprovedByInput | ChangeRequestUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type TokenHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<TokenHistoryCreateWithoutChangedByInput, TokenHistoryUncheckedCreateWithoutChangedByInput> | TokenHistoryCreateWithoutChangedByInput[] | TokenHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutChangedByInput | TokenHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: TokenHistoryUpsertWithWhereUniqueWithoutChangedByInput | TokenHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: TokenHistoryCreateManyChangedByInputEnvelope
    set?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    disconnect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    delete?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    update?: TokenHistoryUpdateWithWhereUniqueWithoutChangedByInput | TokenHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: TokenHistoryUpdateManyWithWhereWithoutChangedByInput | TokenHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: TokenHistoryScalarWhereInput | TokenHistoryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTokensCreatedInput = {
    create?: XOR<UserCreateWithoutTokensCreatedInput, UserUncheckedCreateWithoutTokensCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TokenHistoryCreateNestedManyWithoutTokenInput = {
    create?: XOR<TokenHistoryCreateWithoutTokenInput, TokenHistoryUncheckedCreateWithoutTokenInput> | TokenHistoryCreateWithoutTokenInput[] | TokenHistoryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutTokenInput | TokenHistoryCreateOrConnectWithoutTokenInput[]
    createMany?: TokenHistoryCreateManyTokenInputEnvelope
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
  }

  export type TokenUsageCreateNestedManyWithoutTokenInput = {
    create?: XOR<TokenUsageCreateWithoutTokenInput, TokenUsageUncheckedCreateWithoutTokenInput> | TokenUsageCreateWithoutTokenInput[] | TokenUsageUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTokenInput | TokenUsageCreateOrConnectWithoutTokenInput[]
    createMany?: TokenUsageCreateManyTokenInputEnvelope
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
  }

  export type PatternTokenCreateNestedManyWithoutTokenInput = {
    create?: XOR<PatternTokenCreateWithoutTokenInput, PatternTokenUncheckedCreateWithoutTokenInput> | PatternTokenCreateWithoutTokenInput[] | PatternTokenUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutTokenInput | PatternTokenCreateOrConnectWithoutTokenInput[]
    createMany?: PatternTokenCreateManyTokenInputEnvelope
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
  }

  export type TokenDependencyCreateNestedManyWithoutTokenInput = {
    create?: XOR<TokenDependencyCreateWithoutTokenInput, TokenDependencyUncheckedCreateWithoutTokenInput> | TokenDependencyCreateWithoutTokenInput[] | TokenDependencyUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutTokenInput | TokenDependencyCreateOrConnectWithoutTokenInput[]
    createMany?: TokenDependencyCreateManyTokenInputEnvelope
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
  }

  export type TokenDependencyCreateNestedManyWithoutDependsOnInput = {
    create?: XOR<TokenDependencyCreateWithoutDependsOnInput, TokenDependencyUncheckedCreateWithoutDependsOnInput> | TokenDependencyCreateWithoutDependsOnInput[] | TokenDependencyUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutDependsOnInput | TokenDependencyCreateOrConnectWithoutDependsOnInput[]
    createMany?: TokenDependencyCreateManyDependsOnInputEnvelope
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
  }

  export type ChangeRequestCreateNestedManyWithoutTokenInput = {
    create?: XOR<ChangeRequestCreateWithoutTokenInput, ChangeRequestUncheckedCreateWithoutTokenInput> | ChangeRequestCreateWithoutTokenInput[] | ChangeRequestUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutTokenInput | ChangeRequestCreateOrConnectWithoutTokenInput[]
    createMany?: ChangeRequestCreateManyTokenInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type TokenHistoryUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<TokenHistoryCreateWithoutTokenInput, TokenHistoryUncheckedCreateWithoutTokenInput> | TokenHistoryCreateWithoutTokenInput[] | TokenHistoryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutTokenInput | TokenHistoryCreateOrConnectWithoutTokenInput[]
    createMany?: TokenHistoryCreateManyTokenInputEnvelope
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
  }

  export type TokenUsageUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<TokenUsageCreateWithoutTokenInput, TokenUsageUncheckedCreateWithoutTokenInput> | TokenUsageCreateWithoutTokenInput[] | TokenUsageUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTokenInput | TokenUsageCreateOrConnectWithoutTokenInput[]
    createMany?: TokenUsageCreateManyTokenInputEnvelope
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
  }

  export type PatternTokenUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<PatternTokenCreateWithoutTokenInput, PatternTokenUncheckedCreateWithoutTokenInput> | PatternTokenCreateWithoutTokenInput[] | PatternTokenUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutTokenInput | PatternTokenCreateOrConnectWithoutTokenInput[]
    createMany?: PatternTokenCreateManyTokenInputEnvelope
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
  }

  export type TokenDependencyUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<TokenDependencyCreateWithoutTokenInput, TokenDependencyUncheckedCreateWithoutTokenInput> | TokenDependencyCreateWithoutTokenInput[] | TokenDependencyUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutTokenInput | TokenDependencyCreateOrConnectWithoutTokenInput[]
    createMany?: TokenDependencyCreateManyTokenInputEnvelope
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
  }

  export type TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput = {
    create?: XOR<TokenDependencyCreateWithoutDependsOnInput, TokenDependencyUncheckedCreateWithoutDependsOnInput> | TokenDependencyCreateWithoutDependsOnInput[] | TokenDependencyUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutDependsOnInput | TokenDependencyCreateOrConnectWithoutDependsOnInput[]
    createMany?: TokenDependencyCreateManyDependsOnInputEnvelope
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
  }

  export type ChangeRequestUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<ChangeRequestCreateWithoutTokenInput, ChangeRequestUncheckedCreateWithoutTokenInput> | ChangeRequestCreateWithoutTokenInput[] | ChangeRequestUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutTokenInput | ChangeRequestCreateOrConnectWithoutTokenInput[]
    createMany?: ChangeRequestCreateManyTokenInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type EnumTokenCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TokenCategory
  }

  export type EnumCriticalityFieldUpdateOperationsInput = {
    set?: $Enums.Criticality
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumDeprecationStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeprecationStatus
  }

  export type UserUpdateOneRequiredWithoutTokensCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTokensCreatedInput, UserUncheckedCreateWithoutTokensCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensCreatedInput
    upsert?: UserUpsertWithoutTokensCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensCreatedInput, UserUpdateWithoutTokensCreatedInput>, UserUncheckedUpdateWithoutTokensCreatedInput>
  }

  export type TokenHistoryUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TokenHistoryCreateWithoutTokenInput, TokenHistoryUncheckedCreateWithoutTokenInput> | TokenHistoryCreateWithoutTokenInput[] | TokenHistoryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutTokenInput | TokenHistoryCreateOrConnectWithoutTokenInput[]
    upsert?: TokenHistoryUpsertWithWhereUniqueWithoutTokenInput | TokenHistoryUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TokenHistoryCreateManyTokenInputEnvelope
    set?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    disconnect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    delete?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    update?: TokenHistoryUpdateWithWhereUniqueWithoutTokenInput | TokenHistoryUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TokenHistoryUpdateManyWithWhereWithoutTokenInput | TokenHistoryUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TokenHistoryScalarWhereInput | TokenHistoryScalarWhereInput[]
  }

  export type TokenUsageUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TokenUsageCreateWithoutTokenInput, TokenUsageUncheckedCreateWithoutTokenInput> | TokenUsageCreateWithoutTokenInput[] | TokenUsageUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTokenInput | TokenUsageCreateOrConnectWithoutTokenInput[]
    upsert?: TokenUsageUpsertWithWhereUniqueWithoutTokenInput | TokenUsageUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TokenUsageCreateManyTokenInputEnvelope
    set?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    disconnect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    delete?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    update?: TokenUsageUpdateWithWhereUniqueWithoutTokenInput | TokenUsageUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TokenUsageUpdateManyWithWhereWithoutTokenInput | TokenUsageUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
  }

  export type PatternTokenUpdateManyWithoutTokenNestedInput = {
    create?: XOR<PatternTokenCreateWithoutTokenInput, PatternTokenUncheckedCreateWithoutTokenInput> | PatternTokenCreateWithoutTokenInput[] | PatternTokenUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutTokenInput | PatternTokenCreateOrConnectWithoutTokenInput[]
    upsert?: PatternTokenUpsertWithWhereUniqueWithoutTokenInput | PatternTokenUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: PatternTokenCreateManyTokenInputEnvelope
    set?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    disconnect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    delete?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    update?: PatternTokenUpdateWithWhereUniqueWithoutTokenInput | PatternTokenUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: PatternTokenUpdateManyWithWhereWithoutTokenInput | PatternTokenUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: PatternTokenScalarWhereInput | PatternTokenScalarWhereInput[]
  }

  export type TokenDependencyUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TokenDependencyCreateWithoutTokenInput, TokenDependencyUncheckedCreateWithoutTokenInput> | TokenDependencyCreateWithoutTokenInput[] | TokenDependencyUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutTokenInput | TokenDependencyCreateOrConnectWithoutTokenInput[]
    upsert?: TokenDependencyUpsertWithWhereUniqueWithoutTokenInput | TokenDependencyUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TokenDependencyCreateManyTokenInputEnvelope
    set?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    disconnect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    delete?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    update?: TokenDependencyUpdateWithWhereUniqueWithoutTokenInput | TokenDependencyUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TokenDependencyUpdateManyWithWhereWithoutTokenInput | TokenDependencyUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TokenDependencyScalarWhereInput | TokenDependencyScalarWhereInput[]
  }

  export type TokenDependencyUpdateManyWithoutDependsOnNestedInput = {
    create?: XOR<TokenDependencyCreateWithoutDependsOnInput, TokenDependencyUncheckedCreateWithoutDependsOnInput> | TokenDependencyCreateWithoutDependsOnInput[] | TokenDependencyUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutDependsOnInput | TokenDependencyCreateOrConnectWithoutDependsOnInput[]
    upsert?: TokenDependencyUpsertWithWhereUniqueWithoutDependsOnInput | TokenDependencyUpsertWithWhereUniqueWithoutDependsOnInput[]
    createMany?: TokenDependencyCreateManyDependsOnInputEnvelope
    set?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    disconnect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    delete?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    update?: TokenDependencyUpdateWithWhereUniqueWithoutDependsOnInput | TokenDependencyUpdateWithWhereUniqueWithoutDependsOnInput[]
    updateMany?: TokenDependencyUpdateManyWithWhereWithoutDependsOnInput | TokenDependencyUpdateManyWithWhereWithoutDependsOnInput[]
    deleteMany?: TokenDependencyScalarWhereInput | TokenDependencyScalarWhereInput[]
  }

  export type ChangeRequestUpdateManyWithoutTokenNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutTokenInput, ChangeRequestUncheckedCreateWithoutTokenInput> | ChangeRequestCreateWithoutTokenInput[] | ChangeRequestUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutTokenInput | ChangeRequestCreateOrConnectWithoutTokenInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutTokenInput | ChangeRequestUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: ChangeRequestCreateManyTokenInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutTokenInput | ChangeRequestUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutTokenInput | ChangeRequestUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TokenHistoryCreateWithoutTokenInput, TokenHistoryUncheckedCreateWithoutTokenInput> | TokenHistoryCreateWithoutTokenInput[] | TokenHistoryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenHistoryCreateOrConnectWithoutTokenInput | TokenHistoryCreateOrConnectWithoutTokenInput[]
    upsert?: TokenHistoryUpsertWithWhereUniqueWithoutTokenInput | TokenHistoryUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TokenHistoryCreateManyTokenInputEnvelope
    set?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    disconnect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    delete?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    connect?: TokenHistoryWhereUniqueInput | TokenHistoryWhereUniqueInput[]
    update?: TokenHistoryUpdateWithWhereUniqueWithoutTokenInput | TokenHistoryUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TokenHistoryUpdateManyWithWhereWithoutTokenInput | TokenHistoryUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TokenHistoryScalarWhereInput | TokenHistoryScalarWhereInput[]
  }

  export type TokenUsageUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TokenUsageCreateWithoutTokenInput, TokenUsageUncheckedCreateWithoutTokenInput> | TokenUsageCreateWithoutTokenInput[] | TokenUsageUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTokenInput | TokenUsageCreateOrConnectWithoutTokenInput[]
    upsert?: TokenUsageUpsertWithWhereUniqueWithoutTokenInput | TokenUsageUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TokenUsageCreateManyTokenInputEnvelope
    set?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    disconnect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    delete?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    update?: TokenUsageUpdateWithWhereUniqueWithoutTokenInput | TokenUsageUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TokenUsageUpdateManyWithWhereWithoutTokenInput | TokenUsageUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
  }

  export type PatternTokenUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<PatternTokenCreateWithoutTokenInput, PatternTokenUncheckedCreateWithoutTokenInput> | PatternTokenCreateWithoutTokenInput[] | PatternTokenUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutTokenInput | PatternTokenCreateOrConnectWithoutTokenInput[]
    upsert?: PatternTokenUpsertWithWhereUniqueWithoutTokenInput | PatternTokenUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: PatternTokenCreateManyTokenInputEnvelope
    set?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    disconnect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    delete?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    update?: PatternTokenUpdateWithWhereUniqueWithoutTokenInput | PatternTokenUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: PatternTokenUpdateManyWithWhereWithoutTokenInput | PatternTokenUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: PatternTokenScalarWhereInput | PatternTokenScalarWhereInput[]
  }

  export type TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TokenDependencyCreateWithoutTokenInput, TokenDependencyUncheckedCreateWithoutTokenInput> | TokenDependencyCreateWithoutTokenInput[] | TokenDependencyUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutTokenInput | TokenDependencyCreateOrConnectWithoutTokenInput[]
    upsert?: TokenDependencyUpsertWithWhereUniqueWithoutTokenInput | TokenDependencyUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TokenDependencyCreateManyTokenInputEnvelope
    set?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    disconnect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    delete?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    update?: TokenDependencyUpdateWithWhereUniqueWithoutTokenInput | TokenDependencyUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TokenDependencyUpdateManyWithWhereWithoutTokenInput | TokenDependencyUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TokenDependencyScalarWhereInput | TokenDependencyScalarWhereInput[]
  }

  export type TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput = {
    create?: XOR<TokenDependencyCreateWithoutDependsOnInput, TokenDependencyUncheckedCreateWithoutDependsOnInput> | TokenDependencyCreateWithoutDependsOnInput[] | TokenDependencyUncheckedCreateWithoutDependsOnInput[]
    connectOrCreate?: TokenDependencyCreateOrConnectWithoutDependsOnInput | TokenDependencyCreateOrConnectWithoutDependsOnInput[]
    upsert?: TokenDependencyUpsertWithWhereUniqueWithoutDependsOnInput | TokenDependencyUpsertWithWhereUniqueWithoutDependsOnInput[]
    createMany?: TokenDependencyCreateManyDependsOnInputEnvelope
    set?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    disconnect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    delete?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    connect?: TokenDependencyWhereUniqueInput | TokenDependencyWhereUniqueInput[]
    update?: TokenDependencyUpdateWithWhereUniqueWithoutDependsOnInput | TokenDependencyUpdateWithWhereUniqueWithoutDependsOnInput[]
    updateMany?: TokenDependencyUpdateManyWithWhereWithoutDependsOnInput | TokenDependencyUpdateManyWithWhereWithoutDependsOnInput[]
    deleteMany?: TokenDependencyScalarWhereInput | TokenDependencyScalarWhereInput[]
  }

  export type ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutTokenInput, ChangeRequestUncheckedCreateWithoutTokenInput> | ChangeRequestCreateWithoutTokenInput[] | ChangeRequestUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutTokenInput | ChangeRequestCreateOrConnectWithoutTokenInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutTokenInput | ChangeRequestUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: ChangeRequestCreateManyTokenInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutTokenInput | ChangeRequestUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutTokenInput | ChangeRequestUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type TokenCreateNestedOneWithoutHistoryInput = {
    create?: XOR<TokenCreateWithoutHistoryInput, TokenUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: TokenCreateOrConnectWithoutHistoryInput
    connect?: TokenWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTokenHistoryInput = {
    create?: XOR<UserCreateWithoutTokenHistoryInput, UserUncheckedCreateWithoutTokenHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TokenUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<TokenCreateWithoutHistoryInput, TokenUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: TokenCreateOrConnectWithoutHistoryInput
    upsert?: TokenUpsertWithoutHistoryInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutHistoryInput, TokenUpdateWithoutHistoryInput>, TokenUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutTokenHistoryNestedInput = {
    create?: XOR<UserCreateWithoutTokenHistoryInput, UserUncheckedCreateWithoutTokenHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenHistoryInput
    upsert?: UserUpsertWithoutTokenHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokenHistoryInput, UserUpdateWithoutTokenHistoryInput>, UserUncheckedUpdateWithoutTokenHistoryInput>
  }

  export type ApplicationCreateNestedManyWithoutTeamInput = {
    create?: XOR<ApplicationCreateWithoutTeamInput, ApplicationUncheckedCreateWithoutTeamInput> | ApplicationCreateWithoutTeamInput[] | ApplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTeamInput | ApplicationCreateOrConnectWithoutTeamInput[]
    createMany?: ApplicationCreateManyTeamInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type TokenUsageCreateNestedManyWithoutTeamInput = {
    create?: XOR<TokenUsageCreateWithoutTeamInput, TokenUsageUncheckedCreateWithoutTeamInput> | TokenUsageCreateWithoutTeamInput[] | TokenUsageUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTeamInput | TokenUsageCreateOrConnectWithoutTeamInput[]
    createMany?: TokenUsageCreateManyTeamInputEnvelope
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ApplicationCreateWithoutTeamInput, ApplicationUncheckedCreateWithoutTeamInput> | ApplicationCreateWithoutTeamInput[] | ApplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTeamInput | ApplicationCreateOrConnectWithoutTeamInput[]
    createMany?: ApplicationCreateManyTeamInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type TokenUsageUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TokenUsageCreateWithoutTeamInput, TokenUsageUncheckedCreateWithoutTeamInput> | TokenUsageCreateWithoutTeamInput[] | TokenUsageUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTeamInput | TokenUsageCreateOrConnectWithoutTeamInput[]
    createMany?: TokenUsageCreateManyTeamInputEnvelope
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
  }

  export type ApplicationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ApplicationCreateWithoutTeamInput, ApplicationUncheckedCreateWithoutTeamInput> | ApplicationCreateWithoutTeamInput[] | ApplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTeamInput | ApplicationCreateOrConnectWithoutTeamInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutTeamInput | ApplicationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ApplicationCreateManyTeamInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutTeamInput | ApplicationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutTeamInput | ApplicationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type TokenUsageUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TokenUsageCreateWithoutTeamInput, TokenUsageUncheckedCreateWithoutTeamInput> | TokenUsageCreateWithoutTeamInput[] | TokenUsageUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTeamInput | TokenUsageCreateOrConnectWithoutTeamInput[]
    upsert?: TokenUsageUpsertWithWhereUniqueWithoutTeamInput | TokenUsageUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TokenUsageCreateManyTeamInputEnvelope
    set?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    disconnect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    delete?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    update?: TokenUsageUpdateWithWhereUniqueWithoutTeamInput | TokenUsageUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TokenUsageUpdateManyWithWhereWithoutTeamInput | TokenUsageUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ApplicationCreateWithoutTeamInput, ApplicationUncheckedCreateWithoutTeamInput> | ApplicationCreateWithoutTeamInput[] | ApplicationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutTeamInput | ApplicationCreateOrConnectWithoutTeamInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutTeamInput | ApplicationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ApplicationCreateManyTeamInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutTeamInput | ApplicationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutTeamInput | ApplicationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type TokenUsageUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TokenUsageCreateWithoutTeamInput, TokenUsageUncheckedCreateWithoutTeamInput> | TokenUsageCreateWithoutTeamInput[] | TokenUsageUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutTeamInput | TokenUsageCreateOrConnectWithoutTeamInput[]
    upsert?: TokenUsageUpsertWithWhereUniqueWithoutTeamInput | TokenUsageUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TokenUsageCreateManyTeamInputEnvelope
    set?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    disconnect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    delete?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    update?: TokenUsageUpdateWithWhereUniqueWithoutTeamInput | TokenUsageUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TokenUsageUpdateManyWithWhereWithoutTeamInput | TokenUsageUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<TeamCreateWithoutApplicationsInput, TeamUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutApplicationsInput
    connect?: TeamWhereUniqueInput
  }

  export type TokenUsageCreateNestedManyWithoutApplicationInput = {
    create?: XOR<TokenUsageCreateWithoutApplicationInput, TokenUsageUncheckedCreateWithoutApplicationInput> | TokenUsageCreateWithoutApplicationInput[] | TokenUsageUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutApplicationInput | TokenUsageCreateOrConnectWithoutApplicationInput[]
    createMany?: TokenUsageCreateManyApplicationInputEnvelope
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
  }

  export type ScanResultCreateNestedManyWithoutApplicationInput = {
    create?: XOR<ScanResultCreateWithoutApplicationInput, ScanResultUncheckedCreateWithoutApplicationInput> | ScanResultCreateWithoutApplicationInput[] | ScanResultUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ScanResultCreateOrConnectWithoutApplicationInput | ScanResultCreateOrConnectWithoutApplicationInput[]
    createMany?: ScanResultCreateManyApplicationInputEnvelope
    connect?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
  }

  export type TokenUsageUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<TokenUsageCreateWithoutApplicationInput, TokenUsageUncheckedCreateWithoutApplicationInput> | TokenUsageCreateWithoutApplicationInput[] | TokenUsageUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutApplicationInput | TokenUsageCreateOrConnectWithoutApplicationInput[]
    createMany?: TokenUsageCreateManyApplicationInputEnvelope
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
  }

  export type ScanResultUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<ScanResultCreateWithoutApplicationInput, ScanResultUncheckedCreateWithoutApplicationInput> | ScanResultCreateWithoutApplicationInput[] | ScanResultUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ScanResultCreateOrConnectWithoutApplicationInput | ScanResultCreateOrConnectWithoutApplicationInput[]
    createMany?: ScanResultCreateManyApplicationInputEnvelope
    connect?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
  }

  export type EnumAppTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppType
  }

  export type EnumAppStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppStatus
  }

  export type TeamUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<TeamCreateWithoutApplicationsInput, TeamUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutApplicationsInput
    upsert?: TeamUpsertWithoutApplicationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutApplicationsInput, TeamUpdateWithoutApplicationsInput>, TeamUncheckedUpdateWithoutApplicationsInput>
  }

  export type TokenUsageUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<TokenUsageCreateWithoutApplicationInput, TokenUsageUncheckedCreateWithoutApplicationInput> | TokenUsageCreateWithoutApplicationInput[] | TokenUsageUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutApplicationInput | TokenUsageCreateOrConnectWithoutApplicationInput[]
    upsert?: TokenUsageUpsertWithWhereUniqueWithoutApplicationInput | TokenUsageUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: TokenUsageCreateManyApplicationInputEnvelope
    set?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    disconnect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    delete?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    update?: TokenUsageUpdateWithWhereUniqueWithoutApplicationInput | TokenUsageUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: TokenUsageUpdateManyWithWhereWithoutApplicationInput | TokenUsageUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
  }

  export type ScanResultUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<ScanResultCreateWithoutApplicationInput, ScanResultUncheckedCreateWithoutApplicationInput> | ScanResultCreateWithoutApplicationInput[] | ScanResultUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ScanResultCreateOrConnectWithoutApplicationInput | ScanResultCreateOrConnectWithoutApplicationInput[]
    upsert?: ScanResultUpsertWithWhereUniqueWithoutApplicationInput | ScanResultUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: ScanResultCreateManyApplicationInputEnvelope
    set?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    disconnect?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    delete?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    connect?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    update?: ScanResultUpdateWithWhereUniqueWithoutApplicationInput | ScanResultUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: ScanResultUpdateManyWithWhereWithoutApplicationInput | ScanResultUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: ScanResultScalarWhereInput | ScanResultScalarWhereInput[]
  }

  export type TokenUsageUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<TokenUsageCreateWithoutApplicationInput, TokenUsageUncheckedCreateWithoutApplicationInput> | TokenUsageCreateWithoutApplicationInput[] | TokenUsageUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TokenUsageCreateOrConnectWithoutApplicationInput | TokenUsageCreateOrConnectWithoutApplicationInput[]
    upsert?: TokenUsageUpsertWithWhereUniqueWithoutApplicationInput | TokenUsageUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: TokenUsageCreateManyApplicationInputEnvelope
    set?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    disconnect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    delete?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    connect?: TokenUsageWhereUniqueInput | TokenUsageWhereUniqueInput[]
    update?: TokenUsageUpdateWithWhereUniqueWithoutApplicationInput | TokenUsageUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: TokenUsageUpdateManyWithWhereWithoutApplicationInput | TokenUsageUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
  }

  export type ScanResultUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<ScanResultCreateWithoutApplicationInput, ScanResultUncheckedCreateWithoutApplicationInput> | ScanResultCreateWithoutApplicationInput[] | ScanResultUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ScanResultCreateOrConnectWithoutApplicationInput | ScanResultCreateOrConnectWithoutApplicationInput[]
    upsert?: ScanResultUpsertWithWhereUniqueWithoutApplicationInput | ScanResultUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: ScanResultCreateManyApplicationInputEnvelope
    set?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    disconnect?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    delete?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    connect?: ScanResultWhereUniqueInput | ScanResultWhereUniqueInput[]
    update?: ScanResultUpdateWithWhereUniqueWithoutApplicationInput | ScanResultUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: ScanResultUpdateManyWithWhereWithoutApplicationInput | ScanResultUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: ScanResultScalarWhereInput | ScanResultScalarWhereInput[]
  }

  export type TokenUsageCreatefilePathsInput = {
    set: string[]
  }

  export type TokenCreateNestedOneWithoutUsagesInput = {
    create?: XOR<TokenCreateWithoutUsagesInput, TokenUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: TokenCreateOrConnectWithoutUsagesInput
    connect?: TokenWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTokenUsagesInput = {
    create?: XOR<TeamCreateWithoutTokenUsagesInput, TeamUncheckedCreateWithoutTokenUsagesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTokenUsagesInput
    connect?: TeamWhereUniqueInput
  }

  export type ApplicationCreateNestedOneWithoutTokenUsagesInput = {
    create?: XOR<ApplicationCreateWithoutTokenUsagesInput, ApplicationUncheckedCreateWithoutTokenUsagesInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutTokenUsagesInput
    connect?: ApplicationWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumImplementationFieldUpdateOperationsInput = {
    set?: $Enums.Implementation
  }

  export type TokenUsageUpdatefilePathsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TokenUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<TokenCreateWithoutUsagesInput, TokenUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: TokenCreateOrConnectWithoutUsagesInput
    upsert?: TokenUpsertWithoutUsagesInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutUsagesInput, TokenUpdateWithoutUsagesInput>, TokenUncheckedUpdateWithoutUsagesInput>
  }

  export type TeamUpdateOneRequiredWithoutTokenUsagesNestedInput = {
    create?: XOR<TeamCreateWithoutTokenUsagesInput, TeamUncheckedCreateWithoutTokenUsagesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTokenUsagesInput
    upsert?: TeamUpsertWithoutTokenUsagesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTokenUsagesInput, TeamUpdateWithoutTokenUsagesInput>, TeamUncheckedUpdateWithoutTokenUsagesInput>
  }

  export type ApplicationUpdateOneRequiredWithoutTokenUsagesNestedInput = {
    create?: XOR<ApplicationCreateWithoutTokenUsagesInput, ApplicationUncheckedCreateWithoutTokenUsagesInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutTokenUsagesInput
    upsert?: ApplicationUpsertWithoutTokenUsagesInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutTokenUsagesInput, ApplicationUpdateWithoutTokenUsagesInput>, ApplicationUncheckedUpdateWithoutTokenUsagesInput>
  }

  export type PatternTokenCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternTokenCreateWithoutPatternInput, PatternTokenUncheckedCreateWithoutPatternInput> | PatternTokenCreateWithoutPatternInput[] | PatternTokenUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutPatternInput | PatternTokenCreateOrConnectWithoutPatternInput[]
    createMany?: PatternTokenCreateManyPatternInputEnvelope
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
  }

  export type PatternUsageCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternUsageCreateWithoutPatternInput, PatternUsageUncheckedCreateWithoutPatternInput> | PatternUsageCreateWithoutPatternInput[] | PatternUsageUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternUsageCreateOrConnectWithoutPatternInput | PatternUsageCreateOrConnectWithoutPatternInput[]
    createMany?: PatternUsageCreateManyPatternInputEnvelope
    connect?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
  }

  export type PatternTokenUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternTokenCreateWithoutPatternInput, PatternTokenUncheckedCreateWithoutPatternInput> | PatternTokenCreateWithoutPatternInput[] | PatternTokenUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutPatternInput | PatternTokenCreateOrConnectWithoutPatternInput[]
    createMany?: PatternTokenCreateManyPatternInputEnvelope
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
  }

  export type PatternUsageUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternUsageCreateWithoutPatternInput, PatternUsageUncheckedCreateWithoutPatternInput> | PatternUsageCreateWithoutPatternInput[] | PatternUsageUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternUsageCreateOrConnectWithoutPatternInput | PatternUsageCreateOrConnectWithoutPatternInput[]
    createMany?: PatternUsageCreateManyPatternInputEnvelope
    connect?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
  }

  export type EnumComplexityFieldUpdateOperationsInput = {
    set?: $Enums.Complexity
  }

  export type PatternTokenUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternTokenCreateWithoutPatternInput, PatternTokenUncheckedCreateWithoutPatternInput> | PatternTokenCreateWithoutPatternInput[] | PatternTokenUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutPatternInput | PatternTokenCreateOrConnectWithoutPatternInput[]
    upsert?: PatternTokenUpsertWithWhereUniqueWithoutPatternInput | PatternTokenUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternTokenCreateManyPatternInputEnvelope
    set?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    disconnect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    delete?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    update?: PatternTokenUpdateWithWhereUniqueWithoutPatternInput | PatternTokenUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternTokenUpdateManyWithWhereWithoutPatternInput | PatternTokenUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternTokenScalarWhereInput | PatternTokenScalarWhereInput[]
  }

  export type PatternUsageUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternUsageCreateWithoutPatternInput, PatternUsageUncheckedCreateWithoutPatternInput> | PatternUsageCreateWithoutPatternInput[] | PatternUsageUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternUsageCreateOrConnectWithoutPatternInput | PatternUsageCreateOrConnectWithoutPatternInput[]
    upsert?: PatternUsageUpsertWithWhereUniqueWithoutPatternInput | PatternUsageUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternUsageCreateManyPatternInputEnvelope
    set?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    disconnect?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    delete?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    connect?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    update?: PatternUsageUpdateWithWhereUniqueWithoutPatternInput | PatternUsageUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternUsageUpdateManyWithWhereWithoutPatternInput | PatternUsageUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternUsageScalarWhereInput | PatternUsageScalarWhereInput[]
  }

  export type PatternTokenUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternTokenCreateWithoutPatternInput, PatternTokenUncheckedCreateWithoutPatternInput> | PatternTokenCreateWithoutPatternInput[] | PatternTokenUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTokenCreateOrConnectWithoutPatternInput | PatternTokenCreateOrConnectWithoutPatternInput[]
    upsert?: PatternTokenUpsertWithWhereUniqueWithoutPatternInput | PatternTokenUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternTokenCreateManyPatternInputEnvelope
    set?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    disconnect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    delete?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    connect?: PatternTokenWhereUniqueInput | PatternTokenWhereUniqueInput[]
    update?: PatternTokenUpdateWithWhereUniqueWithoutPatternInput | PatternTokenUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternTokenUpdateManyWithWhereWithoutPatternInput | PatternTokenUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternTokenScalarWhereInput | PatternTokenScalarWhereInput[]
  }

  export type PatternUsageUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternUsageCreateWithoutPatternInput, PatternUsageUncheckedCreateWithoutPatternInput> | PatternUsageCreateWithoutPatternInput[] | PatternUsageUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternUsageCreateOrConnectWithoutPatternInput | PatternUsageCreateOrConnectWithoutPatternInput[]
    upsert?: PatternUsageUpsertWithWhereUniqueWithoutPatternInput | PatternUsageUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternUsageCreateManyPatternInputEnvelope
    set?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    disconnect?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    delete?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    connect?: PatternUsageWhereUniqueInput | PatternUsageWhereUniqueInput[]
    update?: PatternUsageUpdateWithWhereUniqueWithoutPatternInput | PatternUsageUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternUsageUpdateManyWithWhereWithoutPatternInput | PatternUsageUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternUsageScalarWhereInput | PatternUsageScalarWhereInput[]
  }

  export type PatternCreateNestedOneWithoutTokensInput = {
    create?: XOR<PatternCreateWithoutTokensInput, PatternUncheckedCreateWithoutTokensInput>
    connectOrCreate?: PatternCreateOrConnectWithoutTokensInput
    connect?: PatternWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutPatternsInput = {
    create?: XOR<TokenCreateWithoutPatternsInput, TokenUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutPatternsInput
    connect?: TokenWhereUniqueInput
  }

  export type PatternUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<PatternCreateWithoutTokensInput, PatternUncheckedCreateWithoutTokensInput>
    connectOrCreate?: PatternCreateOrConnectWithoutTokensInput
    upsert?: PatternUpsertWithoutTokensInput
    connect?: PatternWhereUniqueInput
    update?: XOR<XOR<PatternUpdateToOneWithWhereWithoutTokensInput, PatternUpdateWithoutTokensInput>, PatternUncheckedUpdateWithoutTokensInput>
  }

  export type TokenUpdateOneRequiredWithoutPatternsNestedInput = {
    create?: XOR<TokenCreateWithoutPatternsInput, TokenUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutPatternsInput
    upsert?: TokenUpsertWithoutPatternsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutPatternsInput, TokenUpdateWithoutPatternsInput>, TokenUncheckedUpdateWithoutPatternsInput>
  }

  export type PatternUsageCreateteamsInput = {
    set: string[]
  }

  export type PatternCreateNestedOneWithoutUsagesInput = {
    create?: XOR<PatternCreateWithoutUsagesInput, PatternUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: PatternCreateOrConnectWithoutUsagesInput
    connect?: PatternWhereUniqueInput
  }

  export type PatternUsageUpdateteamsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PatternUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<PatternCreateWithoutUsagesInput, PatternUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: PatternCreateOrConnectWithoutUsagesInput
    upsert?: PatternUpsertWithoutUsagesInput
    connect?: PatternWhereUniqueInput
    update?: XOR<XOR<PatternUpdateToOneWithWhereWithoutUsagesInput, PatternUpdateWithoutUsagesInput>, PatternUncheckedUpdateWithoutUsagesInput>
  }

  export type TokenCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<TokenCreateWithoutDependenciesInput, TokenUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDependenciesInput
    connect?: TokenWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutDependentsInput = {
    create?: XOR<TokenCreateWithoutDependentsInput, TokenUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDependentsInput
    connect?: TokenWhereUniqueInput
  }

  export type EnumDependencyTypeFieldUpdateOperationsInput = {
    set?: $Enums.DependencyType
  }

  export type TokenUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<TokenCreateWithoutDependenciesInput, TokenUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDependenciesInput
    upsert?: TokenUpsertWithoutDependenciesInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDependenciesInput, TokenUpdateWithoutDependenciesInput>, TokenUncheckedUpdateWithoutDependenciesInput>
  }

  export type TokenUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<TokenCreateWithoutDependentsInput, TokenUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDependentsInput
    upsert?: TokenUpsertWithoutDependentsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDependentsInput, TokenUpdateWithoutDependentsInput>, TokenUncheckedUpdateWithoutDependentsInput>
  }

  export type TokenCreateNestedOneWithoutChangeRequestsInput = {
    create?: XOR<TokenCreateWithoutChangeRequestsInput, TokenUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutChangeRequestsInput
    connect?: TokenWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChangeRequestsInput = {
    create?: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangeRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutChangeRequestInput = {
    create?: XOR<NotificationCreateWithoutChangeRequestInput, NotificationUncheckedCreateWithoutChangeRequestInput> | NotificationCreateWithoutChangeRequestInput[] | NotificationUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutChangeRequestInput | NotificationCreateOrConnectWithoutChangeRequestInput[]
    createMany?: NotificationCreateManyChangeRequestInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutChangeRequestInput = {
    create?: XOR<NotificationCreateWithoutChangeRequestInput, NotificationUncheckedCreateWithoutChangeRequestInput> | NotificationCreateWithoutChangeRequestInput[] | NotificationUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutChangeRequestInput | NotificationCreateOrConnectWithoutChangeRequestInput[]
    createMany?: NotificationCreateManyChangeRequestInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChangeType
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type TokenUpdateOneRequiredWithoutChangeRequestsNestedInput = {
    create?: XOR<TokenCreateWithoutChangeRequestsInput, TokenUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutChangeRequestsInput
    upsert?: TokenUpsertWithoutChangeRequestsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutChangeRequestsInput, TokenUpdateWithoutChangeRequestsInput>, TokenUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutChangeRequestsNestedInput = {
    create?: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangeRequestsInput
    upsert?: UserUpsertWithoutChangeRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChangeRequestsInput, UserUpdateWithoutChangeRequestsInput>, UserUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type UserUpdateOneWithoutApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    upsert?: UserUpsertWithoutApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalsInput, UserUpdateWithoutApprovalsInput>, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type NotificationUpdateManyWithoutChangeRequestNestedInput = {
    create?: XOR<NotificationCreateWithoutChangeRequestInput, NotificationUncheckedCreateWithoutChangeRequestInput> | NotificationCreateWithoutChangeRequestInput[] | NotificationUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutChangeRequestInput | NotificationCreateOrConnectWithoutChangeRequestInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutChangeRequestInput | NotificationUpsertWithWhereUniqueWithoutChangeRequestInput[]
    createMany?: NotificationCreateManyChangeRequestInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutChangeRequestInput | NotificationUpdateWithWhereUniqueWithoutChangeRequestInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutChangeRequestInput | NotificationUpdateManyWithWhereWithoutChangeRequestInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutChangeRequestNestedInput = {
    create?: XOR<NotificationCreateWithoutChangeRequestInput, NotificationUncheckedCreateWithoutChangeRequestInput> | NotificationCreateWithoutChangeRequestInput[] | NotificationUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutChangeRequestInput | NotificationCreateOrConnectWithoutChangeRequestInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutChangeRequestInput | NotificationUpsertWithWhereUniqueWithoutChangeRequestInput[]
    createMany?: NotificationCreateManyChangeRequestInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutChangeRequestInput | NotificationUpdateWithWhereUniqueWithoutChangeRequestInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutChangeRequestInput | NotificationUpdateManyWithWhereWithoutChangeRequestInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationCreatechannelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type ChangeRequestCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ChangeRequestCreateWithoutNotificationsInput, ChangeRequestUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutNotificationsInput
    connect?: ChangeRequestWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type NotificationUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ChangeRequestUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutNotificationsInput, ChangeRequestUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutNotificationsInput
    upsert?: ChangeRequestUpsertWithoutNotificationsInput
    disconnect?: ChangeRequestWhereInput | boolean
    delete?: ChangeRequestWhereInput | boolean
    connect?: ChangeRequestWhereUniqueInput
    update?: XOR<XOR<ChangeRequestUpdateToOneWithWhereWithoutNotificationsInput, ChangeRequestUpdateWithoutNotificationsInput>, ChangeRequestUncheckedUpdateWithoutNotificationsInput>
  }

  export type ScanResultCreateerrorsInput = {
    set: string[]
  }

  export type ApplicationCreateNestedOneWithoutScanResultsInput = {
    create?: XOR<ApplicationCreateWithoutScanResultsInput, ApplicationUncheckedCreateWithoutScanResultsInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutScanResultsInput
    connect?: ApplicationWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ScanResultUpdateerrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ApplicationUpdateOneRequiredWithoutScanResultsNestedInput = {
    create?: XOR<ApplicationCreateWithoutScanResultsInput, ApplicationUncheckedCreateWithoutScanResultsInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutScanResultsInput
    upsert?: ApplicationUpsertWithoutScanResultsInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutScanResultsInput, ApplicationUpdateWithoutScanResultsInput>, ApplicationUncheckedUpdateWithoutScanResultsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTokenCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenCategory | EnumTokenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenCategoryFilter<$PrismaModel> | $Enums.TokenCategory
  }

  export type NestedEnumCriticalityFilter<$PrismaModel = never> = {
    equals?: $Enums.Criticality | EnumCriticalityFieldRefInput<$PrismaModel>
    in?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    not?: NestedEnumCriticalityFilter<$PrismaModel> | $Enums.Criticality
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumDeprecationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeprecationStatus | EnumDeprecationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeprecationStatusFilter<$PrismaModel> | $Enums.DeprecationStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTokenCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenCategory | EnumTokenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenCategory[] | ListEnumTokenCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TokenCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenCategoryFilter<$PrismaModel>
    _max?: NestedEnumTokenCategoryFilter<$PrismaModel>
  }

  export type NestedEnumCriticalityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Criticality | EnumCriticalityFieldRefInput<$PrismaModel>
    in?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Criticality[] | ListEnumCriticalityFieldRefInput<$PrismaModel>
    not?: NestedEnumCriticalityWithAggregatesFilter<$PrismaModel> | $Enums.Criticality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCriticalityFilter<$PrismaModel>
    _max?: NestedEnumCriticalityFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDeprecationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeprecationStatus | EnumDeprecationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeprecationStatus[] | ListEnumDeprecationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeprecationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeprecationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeprecationStatusFilter<$PrismaModel>
    _max?: NestedEnumDeprecationStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAppTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppType | EnumAppTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppTypeFilter<$PrismaModel> | $Enums.AppType
  }

  export type NestedEnumAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusFilter<$PrismaModel> | $Enums.AppStatus
  }

  export type NestedEnumAppTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppType | EnumAppTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppType[] | ListEnumAppTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppTypeFilter<$PrismaModel>
    _max?: NestedEnumAppTypeFilter<$PrismaModel>
  }

  export type NestedEnumAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppStatusFilter<$PrismaModel>
    _max?: NestedEnumAppStatusFilter<$PrismaModel>
  }

  export type NestedEnumImplementationFilter<$PrismaModel = never> = {
    equals?: $Enums.Implementation | EnumImplementationFieldRefInput<$PrismaModel>
    in?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    not?: NestedEnumImplementationFilter<$PrismaModel> | $Enums.Implementation
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumImplementationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Implementation | EnumImplementationFieldRefInput<$PrismaModel>
    in?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Implementation[] | ListEnumImplementationFieldRefInput<$PrismaModel>
    not?: NestedEnumImplementationWithAggregatesFilter<$PrismaModel> | $Enums.Implementation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImplementationFilter<$PrismaModel>
    _max?: NestedEnumImplementationFilter<$PrismaModel>
  }

  export type NestedEnumComplexityFilter<$PrismaModel = never> = {
    equals?: $Enums.Complexity | EnumComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityFilter<$PrismaModel> | $Enums.Complexity
  }

  export type NestedEnumComplexityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Complexity | EnumComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Complexity[] | ListEnumComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityWithAggregatesFilter<$PrismaModel> | $Enums.Complexity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplexityFilter<$PrismaModel>
    _max?: NestedEnumComplexityFilter<$PrismaModel>
  }

  export type NestedEnumDependencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DependencyType | EnumDependencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDependencyTypeFilter<$PrismaModel> | $Enums.DependencyType
  }

  export type NestedEnumDependencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DependencyType | EnumDependencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DependencyType[] | ListEnumDependencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDependencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.DependencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDependencyTypeFilter<$PrismaModel>
    _max?: NestedEnumDependencyTypeFilter<$PrismaModel>
  }

  export type NestedEnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TokenCreateWithoutCreatorInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutCreatorInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutCreatorInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput>
  }

  export type TokenCreateManyCreatorInputEnvelope = {
    data: TokenCreateManyCreatorInput | TokenCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ChangeRequestCreateWithoutRequestedByInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutChangeRequestsInput
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput
    notifications?: NotificationCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateWithoutRequestedByInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    approvedById?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestCreateOrConnectWithoutRequestedByInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutRequestedByInput, ChangeRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type ChangeRequestCreateManyRequestedByInputEnvelope = {
    data: ChangeRequestCreateManyRequestedByInput | ChangeRequestCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type ChangeRequestCreateWithoutApprovedByInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutChangeRequestsInput
    requestedBy: UserCreateNestedOneWithoutChangeRequestsInput
    notifications?: NotificationCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateWithoutApprovedByInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    requestedById: string
    notifications?: NotificationUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestCreateOrConnectWithoutApprovedByInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutApprovedByInput, ChangeRequestUncheckedCreateWithoutApprovedByInput>
  }

  export type ChangeRequestCreateManyApprovedByInputEnvelope = {
    data: ChangeRequestCreateManyApprovedByInput | ChangeRequestCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type TokenHistoryCreateWithoutChangedByInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    token: TokenCreateNestedOneWithoutHistoryInput
  }

  export type TokenHistoryUncheckedCreateWithoutChangedByInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId: string
  }

  export type TokenHistoryCreateOrConnectWithoutChangedByInput = {
    where: TokenHistoryWhereUniqueInput
    create: XOR<TokenHistoryCreateWithoutChangedByInput, TokenHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type TokenHistoryCreateManyChangedByInputEnvelope = {
    data: TokenHistoryCreateManyChangedByInput | TokenHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    changeRequest?: ChangeRequestCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    changeRequestId?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutCreatorInput, TokenUncheckedUpdateWithoutCreatorInput>
    create: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutCreatorInput, TokenUncheckedUpdateWithoutCreatorInput>
  }

  export type TokenUpdateManyWithWhereWithoutCreatorInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    tokenId?: StringFilter<"Token"> | string
    name?: StringFilter<"Token"> | string
    currentVersion?: StringFilter<"Token"> | string
    value?: JsonFilter<"Token">
    category?: EnumTokenCategoryFilter<"Token"> | $Enums.TokenCategory
    criticality?: EnumCriticalityFilter<"Token"> | $Enums.Criticality
    reviewRequired?: BoolFilter<"Token"> | boolean
    deprecationStatus?: EnumDeprecationStatusFilter<"Token"> | $Enums.DeprecationStatus
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    creatorId?: StringFilter<"Token"> | string
  }

  export type ChangeRequestUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: ChangeRequestWhereUniqueInput
    update: XOR<ChangeRequestUpdateWithoutRequestedByInput, ChangeRequestUncheckedUpdateWithoutRequestedByInput>
    create: XOR<ChangeRequestCreateWithoutRequestedByInput, ChangeRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type ChangeRequestUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: ChangeRequestWhereUniqueInput
    data: XOR<ChangeRequestUpdateWithoutRequestedByInput, ChangeRequestUncheckedUpdateWithoutRequestedByInput>
  }

  export type ChangeRequestUpdateManyWithWhereWithoutRequestedByInput = {
    where: ChangeRequestScalarWhereInput
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type ChangeRequestScalarWhereInput = {
    AND?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
    OR?: ChangeRequestScalarWhereInput[]
    NOT?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
    id?: StringFilter<"ChangeRequest"> | string
    type?: EnumChangeTypeFilter<"ChangeRequest"> | $Enums.ChangeType
    proposedChanges?: JsonFilter<"ChangeRequest">
    reason?: StringFilter<"ChangeRequest"> | string
    impact?: JsonFilter<"ChangeRequest">
    status?: EnumRequestStatusFilter<"ChangeRequest"> | $Enums.RequestStatus
    testDeploymentId?: StringNullableFilter<"ChangeRequest"> | string | null
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    tokenId?: StringFilter<"ChangeRequest"> | string
    requestedById?: StringFilter<"ChangeRequest"> | string
    approvedById?: StringNullableFilter<"ChangeRequest"> | string | null
  }

  export type ChangeRequestUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ChangeRequestWhereUniqueInput
    update: XOR<ChangeRequestUpdateWithoutApprovedByInput, ChangeRequestUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ChangeRequestCreateWithoutApprovedByInput, ChangeRequestUncheckedCreateWithoutApprovedByInput>
  }

  export type ChangeRequestUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ChangeRequestWhereUniqueInput
    data: XOR<ChangeRequestUpdateWithoutApprovedByInput, ChangeRequestUncheckedUpdateWithoutApprovedByInput>
  }

  export type ChangeRequestUpdateManyWithWhereWithoutApprovedByInput = {
    where: ChangeRequestScalarWhereInput
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type TokenHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: TokenHistoryWhereUniqueInput
    update: XOR<TokenHistoryUpdateWithoutChangedByInput, TokenHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<TokenHistoryCreateWithoutChangedByInput, TokenHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type TokenHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: TokenHistoryWhereUniqueInput
    data: XOR<TokenHistoryUpdateWithoutChangedByInput, TokenHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type TokenHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: TokenHistoryScalarWhereInput
    data: XOR<TokenHistoryUpdateManyMutationInput, TokenHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type TokenHistoryScalarWhereInput = {
    AND?: TokenHistoryScalarWhereInput | TokenHistoryScalarWhereInput[]
    OR?: TokenHistoryScalarWhereInput[]
    NOT?: TokenHistoryScalarWhereInput | TokenHistoryScalarWhereInput[]
    id?: StringFilter<"TokenHistory"> | string
    version?: StringFilter<"TokenHistory"> | string
    changes?: JsonFilter<"TokenHistory">
    changedAt?: DateTimeFilter<"TokenHistory"> | Date | string
    approvedAt?: DateTimeNullableFilter<"TokenHistory"> | Date | string | null
    rollbackInfo?: JsonNullableFilter<"TokenHistory">
    tokenId?: StringFilter<"TokenHistory"> | string
    changedById?: StringFilter<"TokenHistory"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: EnumPriorityFilter<"Notification"> | $Enums.Priority
    isRead?: BoolFilter<"Notification"> | boolean
    channels?: StringNullableListFilter<"Notification">
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    userId?: StringFilter<"Notification"> | string
    changeRequestId?: StringNullableFilter<"Notification"> | string | null
  }

  export type UserCreateWithoutTokensCreatedInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryCreateNestedManyWithoutChangedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokensCreatedInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestUncheckedCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryUncheckedCreateNestedManyWithoutChangedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokensCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensCreatedInput, UserUncheckedCreateWithoutTokensCreatedInput>
  }

  export type TokenHistoryCreateWithoutTokenInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    changedBy: UserCreateNestedOneWithoutTokenHistoryInput
  }

  export type TokenHistoryUncheckedCreateWithoutTokenInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    changedById: string
  }

  export type TokenHistoryCreateOrConnectWithoutTokenInput = {
    where: TokenHistoryWhereUniqueInput
    create: XOR<TokenHistoryCreateWithoutTokenInput, TokenHistoryUncheckedCreateWithoutTokenInput>
  }

  export type TokenHistoryCreateManyTokenInputEnvelope = {
    data: TokenHistoryCreateManyTokenInput | TokenHistoryCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type TokenUsageCreateWithoutTokenInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTokenUsagesInput
    application: ApplicationCreateNestedOneWithoutTokenUsagesInput
  }

  export type TokenUsageUncheckedCreateWithoutTokenInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    applicationId: string
  }

  export type TokenUsageCreateOrConnectWithoutTokenInput = {
    where: TokenUsageWhereUniqueInput
    create: XOR<TokenUsageCreateWithoutTokenInput, TokenUsageUncheckedCreateWithoutTokenInput>
  }

  export type TokenUsageCreateManyTokenInputEnvelope = {
    data: TokenUsageCreateManyTokenInput | TokenUsageCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type PatternTokenCreateWithoutTokenInput = {
    id?: string
    pattern: PatternCreateNestedOneWithoutTokensInput
  }

  export type PatternTokenUncheckedCreateWithoutTokenInput = {
    id?: string
    patternId: string
  }

  export type PatternTokenCreateOrConnectWithoutTokenInput = {
    where: PatternTokenWhereUniqueInput
    create: XOR<PatternTokenCreateWithoutTokenInput, PatternTokenUncheckedCreateWithoutTokenInput>
  }

  export type PatternTokenCreateManyTokenInputEnvelope = {
    data: PatternTokenCreateManyTokenInput | PatternTokenCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type TokenDependencyCreateWithoutTokenInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    dependsOn: TokenCreateNestedOneWithoutDependentsInput
  }

  export type TokenDependencyUncheckedCreateWithoutTokenInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    dependsOnId: string
  }

  export type TokenDependencyCreateOrConnectWithoutTokenInput = {
    where: TokenDependencyWhereUniqueInput
    create: XOR<TokenDependencyCreateWithoutTokenInput, TokenDependencyUncheckedCreateWithoutTokenInput>
  }

  export type TokenDependencyCreateManyTokenInputEnvelope = {
    data: TokenDependencyCreateManyTokenInput | TokenDependencyCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type TokenDependencyCreateWithoutDependsOnInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    token: TokenCreateNestedOneWithoutDependenciesInput
  }

  export type TokenDependencyUncheckedCreateWithoutDependsOnInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    tokenId: string
  }

  export type TokenDependencyCreateOrConnectWithoutDependsOnInput = {
    where: TokenDependencyWhereUniqueInput
    create: XOR<TokenDependencyCreateWithoutDependsOnInput, TokenDependencyUncheckedCreateWithoutDependsOnInput>
  }

  export type TokenDependencyCreateManyDependsOnInputEnvelope = {
    data: TokenDependencyCreateManyDependsOnInput | TokenDependencyCreateManyDependsOnInput[]
    skipDuplicates?: boolean
  }

  export type ChangeRequestCreateWithoutTokenInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy: UserCreateNestedOneWithoutChangeRequestsInput
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput
    notifications?: NotificationCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateWithoutTokenInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedById: string
    approvedById?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestCreateOrConnectWithoutTokenInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutTokenInput, ChangeRequestUncheckedCreateWithoutTokenInput>
  }

  export type ChangeRequestCreateManyTokenInputEnvelope = {
    data: ChangeRequestCreateManyTokenInput | ChangeRequestCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTokensCreatedInput = {
    update: XOR<UserUpdateWithoutTokensCreatedInput, UserUncheckedUpdateWithoutTokensCreatedInput>
    create: XOR<UserCreateWithoutTokensCreatedInput, UserUncheckedCreateWithoutTokensCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensCreatedInput, UserUncheckedUpdateWithoutTokensCreatedInput>
  }

  export type UserUpdateWithoutTokensCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TokenHistoryUpsertWithWhereUniqueWithoutTokenInput = {
    where: TokenHistoryWhereUniqueInput
    update: XOR<TokenHistoryUpdateWithoutTokenInput, TokenHistoryUncheckedUpdateWithoutTokenInput>
    create: XOR<TokenHistoryCreateWithoutTokenInput, TokenHistoryUncheckedCreateWithoutTokenInput>
  }

  export type TokenHistoryUpdateWithWhereUniqueWithoutTokenInput = {
    where: TokenHistoryWhereUniqueInput
    data: XOR<TokenHistoryUpdateWithoutTokenInput, TokenHistoryUncheckedUpdateWithoutTokenInput>
  }

  export type TokenHistoryUpdateManyWithWhereWithoutTokenInput = {
    where: TokenHistoryScalarWhereInput
    data: XOR<TokenHistoryUpdateManyMutationInput, TokenHistoryUncheckedUpdateManyWithoutTokenInput>
  }

  export type TokenUsageUpsertWithWhereUniqueWithoutTokenInput = {
    where: TokenUsageWhereUniqueInput
    update: XOR<TokenUsageUpdateWithoutTokenInput, TokenUsageUncheckedUpdateWithoutTokenInput>
    create: XOR<TokenUsageCreateWithoutTokenInput, TokenUsageUncheckedCreateWithoutTokenInput>
  }

  export type TokenUsageUpdateWithWhereUniqueWithoutTokenInput = {
    where: TokenUsageWhereUniqueInput
    data: XOR<TokenUsageUpdateWithoutTokenInput, TokenUsageUncheckedUpdateWithoutTokenInput>
  }

  export type TokenUsageUpdateManyWithWhereWithoutTokenInput = {
    where: TokenUsageScalarWhereInput
    data: XOR<TokenUsageUpdateManyMutationInput, TokenUsageUncheckedUpdateManyWithoutTokenInput>
  }

  export type TokenUsageScalarWhereInput = {
    AND?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
    OR?: TokenUsageScalarWhereInput[]
    NOT?: TokenUsageScalarWhereInput | TokenUsageScalarWhereInput[]
    id?: StringFilter<"TokenUsage"> | string
    usageCount?: IntFilter<"TokenUsage"> | number
    lastUsed?: DateTimeFilter<"TokenUsage"> | Date | string
    implementation?: EnumImplementationFilter<"TokenUsage"> | $Enums.Implementation
    filePaths?: StringNullableListFilter<"TokenUsage">
    createdAt?: DateTimeFilter<"TokenUsage"> | Date | string
    updatedAt?: DateTimeFilter<"TokenUsage"> | Date | string
    tokenId?: StringFilter<"TokenUsage"> | string
    teamId?: StringFilter<"TokenUsage"> | string
    applicationId?: StringFilter<"TokenUsage"> | string
  }

  export type PatternTokenUpsertWithWhereUniqueWithoutTokenInput = {
    where: PatternTokenWhereUniqueInput
    update: XOR<PatternTokenUpdateWithoutTokenInput, PatternTokenUncheckedUpdateWithoutTokenInput>
    create: XOR<PatternTokenCreateWithoutTokenInput, PatternTokenUncheckedCreateWithoutTokenInput>
  }

  export type PatternTokenUpdateWithWhereUniqueWithoutTokenInput = {
    where: PatternTokenWhereUniqueInput
    data: XOR<PatternTokenUpdateWithoutTokenInput, PatternTokenUncheckedUpdateWithoutTokenInput>
  }

  export type PatternTokenUpdateManyWithWhereWithoutTokenInput = {
    where: PatternTokenScalarWhereInput
    data: XOR<PatternTokenUpdateManyMutationInput, PatternTokenUncheckedUpdateManyWithoutTokenInput>
  }

  export type PatternTokenScalarWhereInput = {
    AND?: PatternTokenScalarWhereInput | PatternTokenScalarWhereInput[]
    OR?: PatternTokenScalarWhereInput[]
    NOT?: PatternTokenScalarWhereInput | PatternTokenScalarWhereInput[]
    id?: StringFilter<"PatternToken"> | string
    patternId?: StringFilter<"PatternToken"> | string
    tokenId?: StringFilter<"PatternToken"> | string
  }

  export type TokenDependencyUpsertWithWhereUniqueWithoutTokenInput = {
    where: TokenDependencyWhereUniqueInput
    update: XOR<TokenDependencyUpdateWithoutTokenInput, TokenDependencyUncheckedUpdateWithoutTokenInput>
    create: XOR<TokenDependencyCreateWithoutTokenInput, TokenDependencyUncheckedCreateWithoutTokenInput>
  }

  export type TokenDependencyUpdateWithWhereUniqueWithoutTokenInput = {
    where: TokenDependencyWhereUniqueInput
    data: XOR<TokenDependencyUpdateWithoutTokenInput, TokenDependencyUncheckedUpdateWithoutTokenInput>
  }

  export type TokenDependencyUpdateManyWithWhereWithoutTokenInput = {
    where: TokenDependencyScalarWhereInput
    data: XOR<TokenDependencyUpdateManyMutationInput, TokenDependencyUncheckedUpdateManyWithoutTokenInput>
  }

  export type TokenDependencyScalarWhereInput = {
    AND?: TokenDependencyScalarWhereInput | TokenDependencyScalarWhereInput[]
    OR?: TokenDependencyScalarWhereInput[]
    NOT?: TokenDependencyScalarWhereInput | TokenDependencyScalarWhereInput[]
    id?: StringFilter<"TokenDependency"> | string
    relationship?: EnumDependencyTypeFilter<"TokenDependency"> | $Enums.DependencyType
    strength?: IntFilter<"TokenDependency"> | number
    tokenId?: StringFilter<"TokenDependency"> | string
    dependsOnId?: StringFilter<"TokenDependency"> | string
  }

  export type TokenDependencyUpsertWithWhereUniqueWithoutDependsOnInput = {
    where: TokenDependencyWhereUniqueInput
    update: XOR<TokenDependencyUpdateWithoutDependsOnInput, TokenDependencyUncheckedUpdateWithoutDependsOnInput>
    create: XOR<TokenDependencyCreateWithoutDependsOnInput, TokenDependencyUncheckedCreateWithoutDependsOnInput>
  }

  export type TokenDependencyUpdateWithWhereUniqueWithoutDependsOnInput = {
    where: TokenDependencyWhereUniqueInput
    data: XOR<TokenDependencyUpdateWithoutDependsOnInput, TokenDependencyUncheckedUpdateWithoutDependsOnInput>
  }

  export type TokenDependencyUpdateManyWithWhereWithoutDependsOnInput = {
    where: TokenDependencyScalarWhereInput
    data: XOR<TokenDependencyUpdateManyMutationInput, TokenDependencyUncheckedUpdateManyWithoutDependsOnInput>
  }

  export type ChangeRequestUpsertWithWhereUniqueWithoutTokenInput = {
    where: ChangeRequestWhereUniqueInput
    update: XOR<ChangeRequestUpdateWithoutTokenInput, ChangeRequestUncheckedUpdateWithoutTokenInput>
    create: XOR<ChangeRequestCreateWithoutTokenInput, ChangeRequestUncheckedCreateWithoutTokenInput>
  }

  export type ChangeRequestUpdateWithWhereUniqueWithoutTokenInput = {
    where: ChangeRequestWhereUniqueInput
    data: XOR<ChangeRequestUpdateWithoutTokenInput, ChangeRequestUncheckedUpdateWithoutTokenInput>
  }

  export type ChangeRequestUpdateManyWithWhereWithoutTokenInput = {
    where: ChangeRequestScalarWhereInput
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyWithoutTokenInput>
  }

  export type TokenCreateWithoutHistoryInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutHistoryInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutHistoryInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutHistoryInput, TokenUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutTokenHistoryInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestCreateNestedManyWithoutApprovedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokenHistoryInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestUncheckedCreateNestedManyWithoutApprovedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokenHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenHistoryInput, UserUncheckedCreateWithoutTokenHistoryInput>
  }

  export type TokenUpsertWithoutHistoryInput = {
    update: XOR<TokenUpdateWithoutHistoryInput, TokenUncheckedUpdateWithoutHistoryInput>
    create: XOR<TokenCreateWithoutHistoryInput, TokenUncheckedCreateWithoutHistoryInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutHistoryInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutHistoryInput, TokenUncheckedUpdateWithoutHistoryInput>
  }

  export type TokenUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserUpsertWithoutTokenHistoryInput = {
    update: XOR<UserUpdateWithoutTokenHistoryInput, UserUncheckedUpdateWithoutTokenHistoryInput>
    create: XOR<UserCreateWithoutTokenHistoryInput, UserUncheckedCreateWithoutTokenHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokenHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokenHistoryInput, UserUncheckedUpdateWithoutTokenHistoryInput>
  }

  export type UserUpdateWithoutTokenHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUpdateManyWithoutApprovedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicationCreateWithoutTeamInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenUsages?: TokenUsageCreateNestedManyWithoutApplicationInput
    scanResults?: ScanResultCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenUsages?: TokenUsageUncheckedCreateNestedManyWithoutApplicationInput
    scanResults?: ScanResultUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutTeamInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutTeamInput, ApplicationUncheckedCreateWithoutTeamInput>
  }

  export type ApplicationCreateManyTeamInputEnvelope = {
    data: ApplicationCreateManyTeamInput | ApplicationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TokenUsageCreateWithoutTeamInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutUsagesInput
    application: ApplicationCreateNestedOneWithoutTokenUsagesInput
  }

  export type TokenUsageUncheckedCreateWithoutTeamInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    applicationId: string
  }

  export type TokenUsageCreateOrConnectWithoutTeamInput = {
    where: TokenUsageWhereUniqueInput
    create: XOR<TokenUsageCreateWithoutTeamInput, TokenUsageUncheckedCreateWithoutTeamInput>
  }

  export type TokenUsageCreateManyTeamInputEnvelope = {
    data: TokenUsageCreateManyTeamInput | TokenUsageCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationUpsertWithWhereUniqueWithoutTeamInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutTeamInput, ApplicationUncheckedUpdateWithoutTeamInput>
    create: XOR<ApplicationCreateWithoutTeamInput, ApplicationUncheckedCreateWithoutTeamInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutTeamInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutTeamInput, ApplicationUncheckedUpdateWithoutTeamInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutTeamInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutTeamInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: StringFilter<"Application"> | string
    name?: StringFilter<"Application"> | string
    type?: EnumAppTypeFilter<"Application"> | $Enums.AppType
    domain?: StringNullableFilter<"Application"> | string | null
    repository?: StringNullableFilter<"Application"> | string | null
    status?: EnumAppStatusFilter<"Application"> | $Enums.AppStatus
    lastScanned?: DateTimeNullableFilter<"Application"> | Date | string | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
    teamId?: StringFilter<"Application"> | string
  }

  export type TokenUsageUpsertWithWhereUniqueWithoutTeamInput = {
    where: TokenUsageWhereUniqueInput
    update: XOR<TokenUsageUpdateWithoutTeamInput, TokenUsageUncheckedUpdateWithoutTeamInput>
    create: XOR<TokenUsageCreateWithoutTeamInput, TokenUsageUncheckedCreateWithoutTeamInput>
  }

  export type TokenUsageUpdateWithWhereUniqueWithoutTeamInput = {
    where: TokenUsageWhereUniqueInput
    data: XOR<TokenUsageUpdateWithoutTeamInput, TokenUsageUncheckedUpdateWithoutTeamInput>
  }

  export type TokenUsageUpdateManyWithWhereWithoutTeamInput = {
    where: TokenUsageScalarWhereInput
    data: XOR<TokenUsageUpdateManyMutationInput, TokenUsageUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutApplicationsInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenUsages?: TokenUsageCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenUsages?: TokenUsageUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutApplicationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutApplicationsInput, TeamUncheckedCreateWithoutApplicationsInput>
  }

  export type TokenUsageCreateWithoutApplicationInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutUsagesInput
    team: TeamCreateNestedOneWithoutTokenUsagesInput
  }

  export type TokenUsageUncheckedCreateWithoutApplicationInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    teamId: string
  }

  export type TokenUsageCreateOrConnectWithoutApplicationInput = {
    where: TokenUsageWhereUniqueInput
    create: XOR<TokenUsageCreateWithoutApplicationInput, TokenUsageUncheckedCreateWithoutApplicationInput>
  }

  export type TokenUsageCreateManyApplicationInputEnvelope = {
    data: TokenUsageCreateManyApplicationInput | TokenUsageCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type ScanResultCreateWithoutApplicationInput = {
    id?: string
    scanDate?: Date | string
    tokensFound?: number
    coverage?: number
    results: JsonNullValueInput | InputJsonValue
    errors?: ScanResultCreateerrorsInput | string[]
  }

  export type ScanResultUncheckedCreateWithoutApplicationInput = {
    id?: string
    scanDate?: Date | string
    tokensFound?: number
    coverage?: number
    results: JsonNullValueInput | InputJsonValue
    errors?: ScanResultCreateerrorsInput | string[]
  }

  export type ScanResultCreateOrConnectWithoutApplicationInput = {
    where: ScanResultWhereUniqueInput
    create: XOR<ScanResultCreateWithoutApplicationInput, ScanResultUncheckedCreateWithoutApplicationInput>
  }

  export type ScanResultCreateManyApplicationInputEnvelope = {
    data: ScanResultCreateManyApplicationInput | ScanResultCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutApplicationsInput = {
    update: XOR<TeamUpdateWithoutApplicationsInput, TeamUncheckedUpdateWithoutApplicationsInput>
    create: XOR<TeamCreateWithoutApplicationsInput, TeamUncheckedCreateWithoutApplicationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutApplicationsInput, TeamUncheckedUpdateWithoutApplicationsInput>
  }

  export type TeamUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenUsages?: TokenUsageUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenUsages?: TokenUsageUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TokenUsageUpsertWithWhereUniqueWithoutApplicationInput = {
    where: TokenUsageWhereUniqueInput
    update: XOR<TokenUsageUpdateWithoutApplicationInput, TokenUsageUncheckedUpdateWithoutApplicationInput>
    create: XOR<TokenUsageCreateWithoutApplicationInput, TokenUsageUncheckedCreateWithoutApplicationInput>
  }

  export type TokenUsageUpdateWithWhereUniqueWithoutApplicationInput = {
    where: TokenUsageWhereUniqueInput
    data: XOR<TokenUsageUpdateWithoutApplicationInput, TokenUsageUncheckedUpdateWithoutApplicationInput>
  }

  export type TokenUsageUpdateManyWithWhereWithoutApplicationInput = {
    where: TokenUsageScalarWhereInput
    data: XOR<TokenUsageUpdateManyMutationInput, TokenUsageUncheckedUpdateManyWithoutApplicationInput>
  }

  export type ScanResultUpsertWithWhereUniqueWithoutApplicationInput = {
    where: ScanResultWhereUniqueInput
    update: XOR<ScanResultUpdateWithoutApplicationInput, ScanResultUncheckedUpdateWithoutApplicationInput>
    create: XOR<ScanResultCreateWithoutApplicationInput, ScanResultUncheckedCreateWithoutApplicationInput>
  }

  export type ScanResultUpdateWithWhereUniqueWithoutApplicationInput = {
    where: ScanResultWhereUniqueInput
    data: XOR<ScanResultUpdateWithoutApplicationInput, ScanResultUncheckedUpdateWithoutApplicationInput>
  }

  export type ScanResultUpdateManyWithWhereWithoutApplicationInput = {
    where: ScanResultScalarWhereInput
    data: XOR<ScanResultUpdateManyMutationInput, ScanResultUncheckedUpdateManyWithoutApplicationInput>
  }

  export type ScanResultScalarWhereInput = {
    AND?: ScanResultScalarWhereInput | ScanResultScalarWhereInput[]
    OR?: ScanResultScalarWhereInput[]
    NOT?: ScanResultScalarWhereInput | ScanResultScalarWhereInput[]
    id?: StringFilter<"ScanResult"> | string
    scanDate?: DateTimeFilter<"ScanResult"> | Date | string
    tokensFound?: IntFilter<"ScanResult"> | number
    coverage?: FloatFilter<"ScanResult"> | number
    results?: JsonFilter<"ScanResult">
    errors?: StringNullableListFilter<"ScanResult">
    applicationId?: StringFilter<"ScanResult"> | string
  }

  export type TokenCreateWithoutUsagesInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutUsagesInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutUsagesInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUsagesInput, TokenUncheckedCreateWithoutUsagesInput>
  }

  export type TeamCreateWithoutTokenUsagesInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTokenUsagesInput = {
    id?: string
    name: string
    contactEmail: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ApplicationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTokenUsagesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTokenUsagesInput, TeamUncheckedCreateWithoutTokenUsagesInput>
  }

  export type ApplicationCreateWithoutTokenUsagesInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutApplicationsInput
    scanResults?: ScanResultCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutTokenUsagesInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    scanResults?: ScanResultUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutTokenUsagesInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutTokenUsagesInput, ApplicationUncheckedCreateWithoutTokenUsagesInput>
  }

  export type TokenUpsertWithoutUsagesInput = {
    update: XOR<TokenUpdateWithoutUsagesInput, TokenUncheckedUpdateWithoutUsagesInput>
    create: XOR<TokenCreateWithoutUsagesInput, TokenUncheckedCreateWithoutUsagesInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutUsagesInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutUsagesInput, TokenUncheckedUpdateWithoutUsagesInput>
  }

  export type TokenUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TeamUpsertWithoutTokenUsagesInput = {
    update: XOR<TeamUpdateWithoutTokenUsagesInput, TeamUncheckedUpdateWithoutTokenUsagesInput>
    create: XOR<TeamCreateWithoutTokenUsagesInput, TeamUncheckedCreateWithoutTokenUsagesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTokenUsagesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTokenUsagesInput, TeamUncheckedUpdateWithoutTokenUsagesInput>
  }

  export type TeamUpdateWithoutTokenUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTokenUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ApplicationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ApplicationUpsertWithoutTokenUsagesInput = {
    update: XOR<ApplicationUpdateWithoutTokenUsagesInput, ApplicationUncheckedUpdateWithoutTokenUsagesInput>
    create: XOR<ApplicationCreateWithoutTokenUsagesInput, ApplicationUncheckedCreateWithoutTokenUsagesInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutTokenUsagesInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutTokenUsagesInput, ApplicationUncheckedUpdateWithoutTokenUsagesInput>
  }

  export type ApplicationUpdateWithoutTokenUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutApplicationsNestedInput
    scanResults?: ScanResultUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutTokenUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    scanResults?: ScanResultUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type PatternTokenCreateWithoutPatternInput = {
    id?: string
    token: TokenCreateNestedOneWithoutPatternsInput
  }

  export type PatternTokenUncheckedCreateWithoutPatternInput = {
    id?: string
    tokenId: string
  }

  export type PatternTokenCreateOrConnectWithoutPatternInput = {
    where: PatternTokenWhereUniqueInput
    create: XOR<PatternTokenCreateWithoutPatternInput, PatternTokenUncheckedCreateWithoutPatternInput>
  }

  export type PatternTokenCreateManyPatternInputEnvelope = {
    data: PatternTokenCreateManyPatternInput | PatternTokenCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type PatternUsageCreateWithoutPatternInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    teams?: PatternUsageCreateteamsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternUsageUncheckedCreateWithoutPatternInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    teams?: PatternUsageCreateteamsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternUsageCreateOrConnectWithoutPatternInput = {
    where: PatternUsageWhereUniqueInput
    create: XOR<PatternUsageCreateWithoutPatternInput, PatternUsageUncheckedCreateWithoutPatternInput>
  }

  export type PatternUsageCreateManyPatternInputEnvelope = {
    data: PatternUsageCreateManyPatternInput | PatternUsageCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type PatternTokenUpsertWithWhereUniqueWithoutPatternInput = {
    where: PatternTokenWhereUniqueInput
    update: XOR<PatternTokenUpdateWithoutPatternInput, PatternTokenUncheckedUpdateWithoutPatternInput>
    create: XOR<PatternTokenCreateWithoutPatternInput, PatternTokenUncheckedCreateWithoutPatternInput>
  }

  export type PatternTokenUpdateWithWhereUniqueWithoutPatternInput = {
    where: PatternTokenWhereUniqueInput
    data: XOR<PatternTokenUpdateWithoutPatternInput, PatternTokenUncheckedUpdateWithoutPatternInput>
  }

  export type PatternTokenUpdateManyWithWhereWithoutPatternInput = {
    where: PatternTokenScalarWhereInput
    data: XOR<PatternTokenUpdateManyMutationInput, PatternTokenUncheckedUpdateManyWithoutPatternInput>
  }

  export type PatternUsageUpsertWithWhereUniqueWithoutPatternInput = {
    where: PatternUsageWhereUniqueInput
    update: XOR<PatternUsageUpdateWithoutPatternInput, PatternUsageUncheckedUpdateWithoutPatternInput>
    create: XOR<PatternUsageCreateWithoutPatternInput, PatternUsageUncheckedCreateWithoutPatternInput>
  }

  export type PatternUsageUpdateWithWhereUniqueWithoutPatternInput = {
    where: PatternUsageWhereUniqueInput
    data: XOR<PatternUsageUpdateWithoutPatternInput, PatternUsageUncheckedUpdateWithoutPatternInput>
  }

  export type PatternUsageUpdateManyWithWhereWithoutPatternInput = {
    where: PatternUsageScalarWhereInput
    data: XOR<PatternUsageUpdateManyMutationInput, PatternUsageUncheckedUpdateManyWithoutPatternInput>
  }

  export type PatternUsageScalarWhereInput = {
    AND?: PatternUsageScalarWhereInput | PatternUsageScalarWhereInput[]
    OR?: PatternUsageScalarWhereInput[]
    NOT?: PatternUsageScalarWhereInput | PatternUsageScalarWhereInput[]
    id?: StringFilter<"PatternUsage"> | string
    usageCount?: IntFilter<"PatternUsage"> | number
    lastUsed?: DateTimeFilter<"PatternUsage"> | Date | string
    teams?: StringNullableListFilter<"PatternUsage">
    createdAt?: DateTimeFilter<"PatternUsage"> | Date | string
    updatedAt?: DateTimeFilter<"PatternUsage"> | Date | string
    patternId?: StringFilter<"PatternUsage"> | string
  }

  export type PatternCreateWithoutTokensInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: PatternUsageCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateWithoutTokensInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: PatternUsageUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternCreateOrConnectWithoutTokensInput = {
    where: PatternWhereUniqueInput
    create: XOR<PatternCreateWithoutTokensInput, PatternUncheckedCreateWithoutTokensInput>
  }

  export type TokenCreateWithoutPatternsInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutPatternsInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutPatternsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutPatternsInput, TokenUncheckedCreateWithoutPatternsInput>
  }

  export type PatternUpsertWithoutTokensInput = {
    update: XOR<PatternUpdateWithoutTokensInput, PatternUncheckedUpdateWithoutTokensInput>
    create: XOR<PatternCreateWithoutTokensInput, PatternUncheckedCreateWithoutTokensInput>
    where?: PatternWhereInput
  }

  export type PatternUpdateToOneWithWhereWithoutTokensInput = {
    where?: PatternWhereInput
    data: XOR<PatternUpdateWithoutTokensInput, PatternUncheckedUpdateWithoutTokensInput>
  }

  export type PatternUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: PatternUsageUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: PatternUsageUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type TokenUpsertWithoutPatternsInput = {
    update: XOR<TokenUpdateWithoutPatternsInput, TokenUncheckedUpdateWithoutPatternsInput>
    create: XOR<TokenCreateWithoutPatternsInput, TokenUncheckedCreateWithoutPatternsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutPatternsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutPatternsInput, TokenUncheckedUpdateWithoutPatternsInput>
  }

  export type TokenUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type PatternCreateWithoutUsagesInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: PatternTokenCreateNestedManyWithoutPatternInput
  }

  export type PatternUncheckedCreateWithoutUsagesInput = {
    id?: string
    patternId: string
    name: string
    description?: string | null
    complexity?: $Enums.Complexity
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: PatternTokenUncheckedCreateNestedManyWithoutPatternInput
  }

  export type PatternCreateOrConnectWithoutUsagesInput = {
    where: PatternWhereUniqueInput
    create: XOR<PatternCreateWithoutUsagesInput, PatternUncheckedCreateWithoutUsagesInput>
  }

  export type PatternUpsertWithoutUsagesInput = {
    update: XOR<PatternUpdateWithoutUsagesInput, PatternUncheckedUpdateWithoutUsagesInput>
    create: XOR<PatternCreateWithoutUsagesInput, PatternUncheckedCreateWithoutUsagesInput>
    where?: PatternWhereInput
  }

  export type PatternUpdateToOneWithWhereWithoutUsagesInput = {
    where?: PatternWhereInput
    data: XOR<PatternUpdateWithoutUsagesInput, PatternUncheckedUpdateWithoutUsagesInput>
  }

  export type PatternUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: PatternTokenUpdateManyWithoutPatternNestedInput
  }

  export type PatternUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: EnumComplexityFieldUpdateOperationsInput | $Enums.Complexity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: PatternTokenUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type TokenCreateWithoutDependenciesInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutDependenciesInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutDependenciesInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDependenciesInput, TokenUncheckedCreateWithoutDependenciesInput>
  }

  export type TokenCreateWithoutDependentsInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutDependentsInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutDependentsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDependentsInput, TokenUncheckedCreateWithoutDependentsInput>
  }

  export type TokenUpsertWithoutDependenciesInput = {
    update: XOR<TokenUpdateWithoutDependenciesInput, TokenUncheckedUpdateWithoutDependenciesInput>
    create: XOR<TokenCreateWithoutDependenciesInput, TokenUncheckedCreateWithoutDependenciesInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDependenciesInput, TokenUncheckedUpdateWithoutDependenciesInput>
  }

  export type TokenUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenUpsertWithoutDependentsInput = {
    update: XOR<TokenUpdateWithoutDependentsInput, TokenUncheckedUpdateWithoutDependentsInput>
    create: XOR<TokenCreateWithoutDependentsInput, TokenUncheckedCreateWithoutDependentsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDependentsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDependentsInput, TokenUncheckedUpdateWithoutDependentsInput>
  }

  export type TokenUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenCreateWithoutChangeRequestsInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensCreatedInput
    history?: TokenHistoryCreateNestedManyWithoutTokenInput
    usages?: TokenUsageCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyCreateNestedManyWithoutDependsOnInput
  }

  export type TokenUncheckedCreateWithoutChangeRequestsInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    history?: TokenHistoryUncheckedCreateNestedManyWithoutTokenInput
    usages?: TokenUsageUncheckedCreateNestedManyWithoutTokenInput
    patterns?: PatternTokenUncheckedCreateNestedManyWithoutTokenInput
    dependencies?: TokenDependencyUncheckedCreateNestedManyWithoutTokenInput
    dependents?: TokenDependencyUncheckedCreateNestedManyWithoutDependsOnInput
  }

  export type TokenCreateOrConnectWithoutChangeRequestsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutChangeRequestsInput, TokenUncheckedCreateWithoutChangeRequestsInput>
  }

  export type UserCreateWithoutChangeRequestsInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenCreateNestedManyWithoutCreatorInput
    approvals?: ChangeRequestCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryCreateNestedManyWithoutChangedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChangeRequestsInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    approvals?: ChangeRequestUncheckedCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryUncheckedCreateNestedManyWithoutChangedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChangeRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
  }

  export type UserCreateWithoutApprovalsInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequestedByInput
    tokenHistory?: TokenHistoryCreateNestedManyWithoutChangedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovalsInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequestedByInput
    tokenHistory?: TokenHistoryUncheckedCreateNestedManyWithoutChangedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
  }

  export type NotificationCreateWithoutChangeRequestInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutChangeRequestInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    userId: string
  }

  export type NotificationCreateOrConnectWithoutChangeRequestInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutChangeRequestInput, NotificationUncheckedCreateWithoutChangeRequestInput>
  }

  export type NotificationCreateManyChangeRequestInputEnvelope = {
    data: NotificationCreateManyChangeRequestInput | NotificationCreateManyChangeRequestInput[]
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithoutChangeRequestsInput = {
    update: XOR<TokenUpdateWithoutChangeRequestsInput, TokenUncheckedUpdateWithoutChangeRequestsInput>
    create: XOR<TokenCreateWithoutChangeRequestsInput, TokenUncheckedCreateWithoutChangeRequestsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutChangeRequestsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutChangeRequestsInput, TokenUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type TokenUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensCreatedNestedInput
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
  }

  export type TokenUncheckedUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
  }

  export type UserUpsertWithoutChangeRequestsInput = {
    update: XOR<UserUpdateWithoutChangeRequestsInput, UserUncheckedUpdateWithoutChangeRequestsInput>
    create: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChangeRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChangeRequestsInput, UserUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type UserUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUpdateManyWithoutCreatorNestedInput
    approvals?: ChangeRequestUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    approvals?: ChangeRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutApprovalsInput = {
    update: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequestedByNestedInput
    tokenHistory?: TokenHistoryUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    tokenHistory?: TokenHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutChangeRequestInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutChangeRequestInput, NotificationUncheckedUpdateWithoutChangeRequestInput>
    create: XOR<NotificationCreateWithoutChangeRequestInput, NotificationUncheckedCreateWithoutChangeRequestInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutChangeRequestInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutChangeRequestInput, NotificationUncheckedUpdateWithoutChangeRequestInput>
  }

  export type NotificationUpdateManyWithWhereWithoutChangeRequestInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutChangeRequestInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    team: string
    role?: $Enums.Role
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokensCreated?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequestedByInput
    approvals?: ChangeRequestUncheckedCreateNestedManyWithoutApprovedByInput
    tokenHistory?: TokenHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type ChangeRequestCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutChangeRequestsInput
    requestedBy: UserCreateNestedOneWithoutChangeRequestsInput
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput
  }

  export type ChangeRequestUncheckedCreateWithoutNotificationsInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    requestedById: string
    approvedById?: string | null
  }

  export type ChangeRequestCreateOrConnectWithoutNotificationsInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutNotificationsInput, ChangeRequestUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    team?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensCreated?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    approvals?: ChangeRequestUncheckedUpdateManyWithoutApprovedByNestedInput
    tokenHistory?: TokenHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type ChangeRequestUpsertWithoutNotificationsInput = {
    update: XOR<ChangeRequestUpdateWithoutNotificationsInput, ChangeRequestUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ChangeRequestCreateWithoutNotificationsInput, ChangeRequestUncheckedCreateWithoutNotificationsInput>
    where?: ChangeRequestWhereInput
  }

  export type ChangeRequestUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ChangeRequestWhereInput
    data: XOR<ChangeRequestUpdateWithoutNotificationsInput, ChangeRequestUncheckedUpdateWithoutNotificationsInput>
  }

  export type ChangeRequestUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutChangeRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationCreateWithoutScanResultsInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutApplicationsInput
    tokenUsages?: TokenUsageCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutScanResultsInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    tokenUsages?: TokenUsageUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutScanResultsInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutScanResultsInput, ApplicationUncheckedCreateWithoutScanResultsInput>
  }

  export type ApplicationUpsertWithoutScanResultsInput = {
    update: XOR<ApplicationUpdateWithoutScanResultsInput, ApplicationUncheckedUpdateWithoutScanResultsInput>
    create: XOR<ApplicationCreateWithoutScanResultsInput, ApplicationUncheckedCreateWithoutScanResultsInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutScanResultsInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutScanResultsInput, ApplicationUncheckedUpdateWithoutScanResultsInput>
  }

  export type ApplicationUpdateWithoutScanResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutApplicationsNestedInput
    tokenUsages?: TokenUsageUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutScanResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    tokenUsages?: TokenUsageUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type TokenCreateManyCreatorInput = {
    id?: string
    tokenId: string
    name: string
    currentVersion: string
    value: JsonNullValueInput | InputJsonValue
    category: $Enums.TokenCategory
    criticality?: $Enums.Criticality
    reviewRequired?: boolean
    deprecationStatus?: $Enums.DeprecationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeRequestCreateManyRequestedByInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    approvedById?: string | null
  }

  export type ChangeRequestCreateManyApprovedByInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    requestedById: string
  }

  export type TokenHistoryCreateManyChangedByInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId: string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    changeRequestId?: string | null
  }

  export type TokenUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: TokenHistoryUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: TokenHistoryUncheckedUpdateManyWithoutTokenNestedInput
    usages?: TokenUsageUncheckedUpdateManyWithoutTokenNestedInput
    patterns?: PatternTokenUncheckedUpdateManyWithoutTokenNestedInput
    dependencies?: TokenDependencyUncheckedUpdateManyWithoutTokenNestedInput
    dependents?: TokenDependencyUncheckedUpdateManyWithoutDependsOnNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currentVersion?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    category?: EnumTokenCategoryFieldUpdateOperationsInput | $Enums.TokenCategory
    criticality?: EnumCriticalityFieldUpdateOperationsInput | $Enums.Criticality
    reviewRequired?: BoolFieldUpdateOperationsInput | boolean
    deprecationStatus?: EnumDeprecationStatusFieldUpdateOperationsInput | $Enums.DeprecationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput
    notifications?: NotificationUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeRequestUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutChangeRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
    notifications?: NotificationUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
    notifications?: NotificationUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    requestedById?: StringFieldUpdateOperationsInput | string
  }

  export type TokenHistoryUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    token?: TokenUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type TokenHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeRequest?: ChangeRequestUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenHistoryCreateManyTokenInput = {
    id?: string
    version: string
    changes: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    approvedAt?: Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    changedById: string
  }

  export type TokenUsageCreateManyTokenInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
    applicationId: string
  }

  export type PatternTokenCreateManyTokenInput = {
    id?: string
    patternId: string
  }

  export type TokenDependencyCreateManyTokenInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    dependsOnId: string
  }

  export type TokenDependencyCreateManyDependsOnInput = {
    id?: string
    relationship?: $Enums.DependencyType
    strength?: number
    tokenId: string
  }

  export type ChangeRequestCreateManyTokenInput = {
    id?: string
    type: $Enums.ChangeType
    proposedChanges: JsonNullValueInput | InputJsonValue
    reason: string
    impact: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequestStatus
    testDeploymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedById: string
    approvedById?: string | null
  }

  export type TokenHistoryUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: UserUpdateOneRequiredWithoutTokenHistoryNestedInput
  }

  export type TokenHistoryUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type TokenHistoryUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackInfo?: NullableJsonNullValueInput | InputJsonValue
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTokenUsagesNestedInput
    application?: ApplicationUpdateOneRequiredWithoutTokenUsagesNestedInput
  }

  export type TokenUsageUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternTokenUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    pattern?: PatternUpdateOneRequiredWithoutTokensNestedInput
  }

  export type PatternTokenUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternTokenUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenDependencyUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    dependsOn?: TokenUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TokenDependencyUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    dependsOnId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenDependencyUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    dependsOnId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenDependencyUpdateWithoutDependsOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    token?: TokenUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type TokenDependencyUncheckedUpdateWithoutDependsOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenDependencyUncheckedUpdateManyWithoutDependsOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumDependencyTypeFieldUpdateOperationsInput | $Enums.DependencyType
    strength?: IntFieldUpdateOperationsInput | number
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type ChangeRequestUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput
    notifications?: NotificationUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    proposedChanges?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    impact?: JsonNullValueInput | InputJsonValue
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    testDeploymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationCreateManyTeamInput = {
    id?: string
    name: string
    type: $Enums.AppType
    domain?: string | null
    repository?: string | null
    status?: $Enums.AppStatus
    lastScanned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUsageCreateManyTeamInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    applicationId: string
  }

  export type ApplicationUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenUsages?: TokenUsageUpdateManyWithoutApplicationNestedInput
    scanResults?: ScanResultUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenUsages?: TokenUsageUncheckedUpdateManyWithoutApplicationNestedInput
    scanResults?: ScanResultUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAppTypeFieldUpdateOperationsInput | $Enums.AppType
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    repository?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    lastScanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUsageUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutUsagesNestedInput
    application?: ApplicationUpdateOneRequiredWithoutTokenUsagesNestedInput
  }

  export type TokenUsageUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageCreateManyApplicationInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    implementation: $Enums.Implementation
    filePaths?: TokenUsageCreatefilePathsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId: string
    teamId: string
  }

  export type ScanResultCreateManyApplicationInput = {
    id?: string
    scanDate?: Date | string
    tokensFound?: number
    coverage?: number
    results: JsonNullValueInput | InputJsonValue
    errors?: ScanResultCreateerrorsInput | string[]
  }

  export type TokenUsageUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutUsagesNestedInput
    team?: TeamUpdateOneRequiredWithoutTokenUsagesNestedInput
  }

  export type TokenUsageUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUsageUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    implementation?: EnumImplementationFieldUpdateOperationsInput | $Enums.Implementation
    filePaths?: TokenUsageUpdatefilePathsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type ScanResultUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
  }

  export type ScanResultUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
  }

  export type ScanResultUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scanDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokensFound?: IntFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    errors?: ScanResultUpdateerrorsInput | string[]
  }

  export type PatternTokenCreateManyPatternInput = {
    id?: string
    tokenId: string
  }

  export type PatternUsageCreateManyPatternInput = {
    id?: string
    usageCount?: number
    lastUsed?: Date | string
    teams?: PatternUsageCreateteamsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternTokenUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: TokenUpdateOneRequiredWithoutPatternsNestedInput
  }

  export type PatternTokenUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternTokenUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
  }

  export type PatternUsageUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternUsageUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternUsageUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: PatternUsageUpdateteamsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyChangeRequestInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority?: $Enums.Priority
    isRead?: boolean
    channels?: NotificationCreatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    userId: string
  }

  export type NotificationUpdateWithoutChangeRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutChangeRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutChangeRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isRead?: BoolFieldUpdateOperationsInput | boolean
    channels?: NotificationUpdatechannelsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenCountOutputTypeDefaultArgs instead
     */
    export type TokenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationCountOutputTypeDefaultArgs instead
     */
    export type ApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatternCountOutputTypeDefaultArgs instead
     */
    export type PatternCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatternCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeRequestCountOutputTypeDefaultArgs instead
     */
    export type ChangeRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDefaultArgs instead
     */
    export type TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenHistoryDefaultArgs instead
     */
    export type TokenHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationDefaultArgs instead
     */
    export type ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenUsageDefaultArgs instead
     */
    export type TokenUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatternDefaultArgs instead
     */
    export type PatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatternTokenDefaultArgs instead
     */
    export type PatternTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatternTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatternUsageDefaultArgs instead
     */
    export type PatternUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatternUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDependencyDefaultArgs instead
     */
    export type TokenDependencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDependencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeRequestDefaultArgs instead
     */
    export type ChangeRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScanResultDefaultArgs instead
     */
    export type ScanResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScanResultDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}